<?php
// $Id$

/**
 * Implements hook_help().
 */
function search_api_facets_help($path, array $arg) {
  if ($path == 'admin/config/search/search_api/index/%/facets') {
    return t('Select the indexed fields for which you want to create facet blocks. ' .
        'Before facet blocks are actually displayed, you will have to enable and configure them at the <a href="!url">block administration page</a>.',
        array('!url' => url('admin/structure/block')));
  }
}

/**
 * Implements hook_menu().
 */
function search_api_facets_menu() {
  $items['admin/config/search/search_api/index/%search_api_index/facets'] = array(
    'title' => 'Facets',
    'description' => 'Select the facet blocks to display.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_facets_index_select', 5),
    'access arguments' => array('administer search_api'),
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
    'file' => 'search_api_facets.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function search_api_facets_theme() {
  $themes['search_api_facets_form_table'] = array(
    'render element' => 'element',
    'file' => 'search_api_facets.admin.inc',
  );

  return $themes;
}

/**
 * Implements hook_block_info().
 */
function search_api_facets_block_info() {
  $blocks = array();
  $facets = search_api_facet_load(array('enabled' => TRUE));
  foreach ($facets as $facet) {
    $blocks[$facet->delta]['info'] = $facet->name;
    // It will hardly ever be possible to cache facet blocks sensibly.
    $blocks[$facet->delta]['cache'] = DRUPAL_NO_CACHE;
    // Use this so facet blocks are initially grouped together.
    $blocks[$facet->delta]['weight'] = 5;
  }
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function search_api_facets_block_configure($delta = '') {
  $facet = search_api_facet_load($delta);
  if (!$facet) {
    return array();
  }
  $index = search_api_index_load($facet->index_id);
  if (!$index || empty($index->options['fields'][$facet->field])) {
    drupal_set_message(t("This facet's index field is unknown."), 'error');
    return array();
  }
  $field = $index->options['fields'][$facet->field];
  $options = $facet->options += array(
    'limit' => 10,
    'min_count' => 1,
    'sort' => 'count',
    'missing' => TRUE,
    'default_true' => TRUE,
    'ids_list' => array(),
  );

  $form['#element_validate'] = array('search_api_facets_block_configure_validate');
  $form['index_description'] = array(
    '#type' => 'item',
    '#title' => t('Search index'),
    '#description' => l($index->name, 'admin/config/search/search_api/index/' . $index->id),
  );
  $form['field_description'] = array(
    '#type' => 'item',
    '#title' => t('Field'),
    '#description' => check_plain($field['name']),
  );
  $form['limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of terms'),
    '#description' => t('The maximum number of facet terms to be displayed in this block. Leave blank or set to 0 for no limit.'),
    '#default_value' => $options['limit'],
  );
  $form['min_count'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum result count'),
    '#description' => t('The minimum number of results a facet value has to have in order to be displayed.'),
    '#default_value' => $options['min_count'],
  );
  $form['sort'] = array(
    '#type' => 'select',
    '#title' => t('Order'),
    '#options' => array(
      'count' => t('Order by result count'),
      'name' => t('Order by name'),
    ),
    '#default_value' => $options['sort'],
  );
  $form['missing'] = array(
    '#type' => 'checkbox',
    '#title' => t('Include "missing" facet'),
    '#description' => t('Include a facet term for all results without a value for this field.'),
    '#default_value' => $options['missing'],
  );

  $search_ids = variable_get('search_api_facets_search_ids', array());
  if (empty($search_ids[$index->id])) {
    $form['default_true'] = array(
      '#type' => 'value',
      '#value' => $options['default_true'],
    );
    $form['ids_list'] = array(
      '#type' => 'value',
      '#value' => $options['ids_list'],
    );
  }
  else {
    $form['default_true'] = array(
      '#type' => 'select',
      '#title' => t('Display for searches'),
      '#options' => array(
        TRUE => t('For all except the selected'),
        FALSE => t('Only for the selected'),
      ),
      '#default_value' => $options['default_true'],
    );
    $form['ids_list'] = array(
      '#type' => 'select',
      '#title' => t('Search IDs'),
      '#options' => $search_ids[$index->id],
      '#default_value' => $options['ids_list'],
    );
  }

  $form['facet'] = array(
    '#type' => 'value',
    '#value' => $facet,
  );

  return $form;
}

/**
 * Validation function for search_api_facets_block_configure().
 */
function search_api_facets_block_configure_validate(array $element, array &$form_state) {
  $limit = $element['limit']['#value'];
  if ($limit && (!is_numeric($limit) || $limit < 0 || strpos($limit, '.') !== FALSE)) {
    form_error($element['limit'], t('The number of terms has to be a non-negative integer, or left blank.'));
  }
  $min_count = $element['min_count']['#value'];
  if (!$min_count || !is_numeric($min_count) || $min_count <= 0 || strpos($min_count, '.') !== FALSE) {
    form_error($element['min_count'], t('The minimum count has to be a positive integer.'));
  }
}

/**
 * Implements hook_block_save().
 */
function search_api_facets_block_save($delta = '', array $edit = array()) {
  $facet = $edit['facet'];
  $options = $facet->options + array(
    'limit'        => (int) $edit['limit'],
    'min_count'    => (int) $edit['min_count'],
    'sort'         => $edit['sort'],
    'missing'      => (boolean) $edit['missing'],
    'default_true' => (boolean) $edit['default_true'],
    'ids_list'     => $edit['ids_list'],
  );
  // We refresh the options each time the form is viewes. Similar behaviour
  // exists for modules, menus, blocks and themes, so â€“ why not?
  if (empty($options['type']) || $options['type'] == 'options') {
    $index = search_api_index_load($facet->index_id);
    $type = $index->options['fields'][$facet->field]['type'];
    $options['type'] = search_api_extract_inner_type($type);
    $wrapper = entity_metadata_wrapper($index->entity_type);
    foreach (explode(':', $facet->field) as $part) {
      if (!isset($wrapper->$part)) {
        $wrapper = NULL;
        break;
      }
      $wrapper = $wrapper->$part;
    }
    if ($wrapper && $wrapper->optionsList()) {
      $options['type'] = 'options';
      $options['options'] = $wrapper->optionsList();
    }
  }
  if ($options != $facet->options) {
    $facet->options = $options;
    search_api_facet_save($facet);
  }
}

/**
 * Implements hook_block_view().
 */
function search_api_facets_block_view($delta = '') {
  $facet = search_api_facet_load($delta);
  if (empty($facet->enabled)) {
    return;
  }
  $options = $facet->options;
  foreach (search_api_current_search() as $search_id => $search) {
    list($query, $results) = $search;
    $index = $query->getIndex();
    if ($facet->index_id == $index->id) {
      if (array_search($search_id, $options['ids_list']) === FALSE) {
        $search_ids = variable_get('search_api_facets_search_ids', array());
        if (empty($search_ids[$search_id])) {
          // Remember this search ID.
          $search_ids[$search_id] = $search_id;
          variable_set('search_api_facets_search_ids', $search_ids);
        }
        if ($options['default_true']) {
          break; // Search matches.
        }
      }
      elseif (!$options['default_true']) {
        break; // Search matches.
      }
    }

    // Search doesn't match, set $index to NULL to recognize this.
    $index = NULL;
  }
  if (!isset($index)) {
    return;
  }
  // @todo View facet block.
}

/**
 * Load one or more facets. Either the block delta or an array of conditions
 * might be given.
 *
 * @param $conditions
 *   Either a facet's delta, or an array containing conditions in the form
 *   $field => $value for the facets to be returned. An empty array will return
 *   all defined facets.
 * @param $reset
 *   If set to TRUE, the returned facets will be freshly loaded, instead of
 *   being loaded from the cache.
 *
 * @return stdClass
 *   Either the facet with the specified delta, or an array of facets matching
 *   the specified conditions, keyed by delta.
 */
function search_api_facet_load($conditions = array(), $reset = FALSE) {
  if (is_scalar($conditions)) {
    $delta = $conditions;
    // At the moment, we only use caching when returning a single facet.
    $cache = &drupal_static(__FUNCTION__);
    if (!isset($cache[$delta]) || $reset) {
      $cache[$delta] = db_query('SELECT * FROM {search_api_facet} WHERE delta = :delta', array(':delta' => $delta))->fetch();
      $cache[$delta]->options = $cache[$delta]->options ? unserialize($cache[$delta]->options) : array();
    }
    return $cache[$delta];
  }
  $select = db_select('search_api_facet', 'f');
  $select->fields('f');
  foreach ($conditions as $field => $value) {
    $select->condition($field, $value);
  }
  $facets = $select->execute()->fetchAllAssoc('delta');
  foreach ($facets as $facet) {
    $facet->options = $facet->options ? unserialize($facet->options) : array();
  }
  return $facets;
}

/**
 * Saves a facet.
 * If $facet->delta is empty, it will be computed automatically. In this case,
 * or if $facet->is_new is set, the facet will be inserted. Otherwise, it will
 * be updated.
 *
 * @param stdClass $facet
 *   The facet object to save.
 */
function search_api_facet_save(stdClass $facet) {
  if (!empty($facet->delta) && empty($facet->is_new)) {
    drupal_write_record('search_api_facet', $facet, 'delta');
    if ($facet->enabled != search_api_facet_load($facet->delta, TRUE)->enabled) {
      block_flush_caches();
    }
    return;
  }
  if (empty($facet->delta)) {
    // Construct a delta using index id and field.
    // We have to ensure that it's both unique and at most 32 characters long,
    // leading to a bit of complexity.
    $delta = 'index' . $facet->index_id . '_' . preg_replace('/\W+/', '_', $facet->field);
    $base = $delta = substr($delta, 0, 32);
    $i = 0;
    while (db_query('SELECT COUNT(1) FROM {search_api_facet} WHERE delta = :delta', array(':delta' => $delta))) {
      $suffix = '_' . ++$i;
      $delta = substr($base, 0, 32 - strlen($suffix)) . $suffix;
    }
    $facet->delta = $delta;
  }
  drupal_write_record('search_api_facet', $facet);
  if ($facet->enabled) {
    block_flush_caches();
  }
}

/**
 * Deletes one or more facets.
 *
 * @param $conditions
 *   Analogous to search_api_facet_load(), this can be either a facet delta or
 *   an array of conditions.
 *
 * @return
 *   TRUE, if any facets were successfully deleted, FALSE otherwise.
 */
function search_api_facet_delete($conditions = array()) {
  if (is_scalar($conditions)) {
    $delta = $conditions;
    return db_delete('search_api_facet')
      ->condition('delta', $delta)
      ->execute() != 0;
  }
  $del = db_delete('search_api_facet');
  foreach ($conditions as $field => $value) {
    $del->condition($field, $value);
  }
  if ($del->execute()) {
    block_flush_caches();
    return TRUE;
  }
  return FALSE;
}

/**
 * Function for retrieving the active filters for a certain search.
 *
 * Filters are taken from URL parameters named "filter_ID", or just "filter"
 * when only one facetted search is active.
 *
 * @param SearchApiQueryInterface $query
 *   The query for which to create the filters.
 *
 * @return array
 *   An array with field names as keys, mapped to a type-specific filter value.
 */
function search_api_facet_get_filter(SearchApiQueryInterface $query) {
  $params = drupal_get_query_parameters();
  $search_id = $query->getOption('search id');

  if (isset($search_id) && isset($params['filter_' . $search_id])) {
    $filters = $params['filter_' . $search_id];
  }
  elseif (isset($params['filter'])) {
    $filters = $params['filter'];
  }
  return empty($filters) ? array() : $filters;
}
