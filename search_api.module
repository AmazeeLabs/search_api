<?php
/**
 * @file
 * Contains the Search API hook implementations.
 */

use Drupal\Component\Utility\String;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\TypedData\ComplexDataInterface;
use Drupal\search_api\Server\ServerInterface;

/*
 * Constant definitions.
 */

/**
 * Default number of items indexed per cron batch for each enabled index.
 */
define('SEARCH_API_DEFAULT_CRON_LIMIT', 50);

/*
 * Hook implementations.
 */

/**
 * Implements hook_menu_link_defaults().
 */
function search_api_menu_link_defaults() {
  return array(
    'search_api.overview' => array(
      'link_title' => 'Search API',
      'description' => 'Create and configure search engines.',
      'route_name' => 'search_api.overview',
      'parent' => 'system.admin_config_search',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function search_api_permission() {
  return array(
    'administer search_api' => array(
      'title' => t('Administer Search API'),
      'description' => t('Create and configure Search API servers and indexes.'),
    ),
  );
}

/**
 * Implements hook_entity_insert().
 */
function search_api_entity_insert(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityInterface) {
    $entity_type_id = $entity->getEntityTypeId();
    $entity_bundle = $entity->bundle();

    $entity_query = \Drupal::entityQuery('search_api_index')
      ->condition('datasourcePluginId', $entity_type_id, 'ENDS_WITH')
      ->condition('datasourcePluginConfig.bundles.*', $entity_bundle, 'CONTAINS');

    $index_names = $entity_query->execute();
    $indexes = entity_load_multiple('search_api_index', $index_names);

    foreach ($indexes as $index) {
      /** @var \Drupal\search_api\Entity\Index $index */
      if ($index->isServerEnabled()) {
        $index->getDatasource()->getTracker()->trackInsert(array($entity->id()));
      }
    }
  }
}

/**
 * Implements hook_entity_update().
 */
function search_api_entity_update(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityInterface) {
    // @todo: Track entity change.
  }
}

/**
 * Implements hook_entity_delete().
 */
function search_api_entity_delete(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityInterface) {
    // @todo: Track entity delete.
  }
}

/**
 * Implements hook_entity_operation_alter().
 *
 * @todo rewrite it regarding to https://drupal.org/node/1839516
 * @todo Should it be moved to SearchApiController->buildRow() ?
 */
function search_api_entity_operation_alter(array &$operations, \Drupal\Core\Entity\EntityInterface $entity) {
  if (($entity->getEntityTypeId() == 'search_api_index' || $entity->getEntityTypeId() == 'search_api_server')
    && !$entity->status() && !empty($operations['enable'])) {
    if ($entity->getEntityTypeId() == 'search_api_index') {
      $operations['enable']['route_name'] = 'search_api.index_bypass_enable';
    }
    else {
      $operations['enable']['route_name'] = 'search_api.server_bypass_enable';
    }

    $operations['enable']['route_parameters']['token'] = \Drupal::csrfToken()->get($entity->id());
  }
}

/**
 * Determines whether a field of the given type contains text data.
 *
 * @param string $type
 *   A string containing the type to check.
 * @param array $allowed
 *   Optionally, an array of allowed types.
 *
 * @return bool
 *   TRUE if $type is either one of the specified types, or a list of such
 *   values. FALSE otherwise.
 */
function search_api_is_text_type($type, array $allowed = array('text')) {
  return in_array($type, $allowed);
}

/**
 * Checks whether it is possible to sort on fields of the given type.
 *
 * @param $type
 *   The type to check for.
 *
 * @todo
 *   Make sure you take the field object and check the isMultiple parameter
 *
 * @return bool
 *   TRUE if this type is sortable, FALSE otherwise.
 */
function search_api_is_sortable_type($type) {
  return !search_api_is_text_type($type);
}

/**
 * Returns all field types recognized by the Search API framework.
 *
 * @return array
 *   An associative array with all recognized types as keys, mapped to their
 *   translated display names.
 *
 * @see search_api_default_index_types()
 * @see search_api_get_data_type_info()
 */
function search_api_data_types() {
  $types = search_api_default_data_types();
  foreach (search_api_get_data_type_info() as $id => $type) {
    $types[$id] = $type['name'];
  }

  return $types;
}

/**
 * Get the mapping between data types and field types
 *
 * @return array
 *   $mapping array with the field type that is requested and it's default data type for a sensible default
 */
function search_api_field_type_mapping() {

  /** @var \Drupal\Core\Field\FieldTypePluginManager $field_type_service */
  $field_type_service = \Drupal::service('plugin.manager.field.field_type');
  $field_types = $field_type_service->getDefinitions();

  $mapping = array();
  foreach ($field_types as $field_type_id => $field_type) {
    /** @var $field_type \Drupal\Core\Field\FieldDefinition */
    switch ($field_type_id) {
      case 'comment':
      case 'list_text':
      case 'text':
      case 'text_long':
      case 'text_with_summary':
        $mapping[$field_type_id] = 'text';
        break;
      case 'path':
      case 'uri':
      case 'email':
      case 'language':
      case 'string':
      case 'string_long':
      case 'uuid':
        $mapping[$field_type_id] = 'string';
        break;
      case 'datetime':
      case 'date':
      case 'changed':
      case 'created':
      case 'timestamp':
        $mapping[$field_type_id] = 'date';
        break;
      case 'list_boolean':
      case 'boolean':
        $mapping[$field_type_id] = 'boolean';
        break;
      case 'list_float':
      case 'float':
        $mapping[$field_type_id] = 'float';
        break;
      case 'list_integer':
      case 'integer':
        $mapping[$field_type_id] = 'integer';
        break;
      case 'decimal':
        $mapping[$field_type_id] = 'decimal';
        break;
      case 'token':
        $mapping[$field_type_id] = 'string';
        break;
    }
  }
  // Allow other modules to intercept and define what default type they want to use for their field type.
  \Drupal::moduleHandler()->alter('search_api_field_type_mapping', $mapping);
  return $mapping;
}

/**
 * Returns the default field types recognized by the Search API framework.
 *
 * @return array
 *   An associative array with the default types as keys, mapped to their
 *   translated display names.
 */
function search_api_default_data_types() {
  return array(
    'text' => t('Fulltext'),
    'string' => t('String'),
    'integer' => t('Integer'),
    'decimal' => t('Decimal'),
    'date' => t('Date'),
    'boolean' => t('Boolean'),
  );
}

/**
 * Returns either all custom field type definitions, or a specific one.
 *
 * @param $type
 *   If specified, the type whose definition should be returned.
 *
 * @return array
 *   If $type was not given, an array containing all custom data types, in the
 *   format specified by hook_search_api_data_type_info().
 *   Otherwise, the definition for the given type, or NULL if it is unknown.
 *
 * @see hook_search_api_data_type_info()
 */
function search_api_get_data_type_info($type = NULL) {
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    $default_types = search_api_default_data_types();
    $types =  \Drupal::moduleHandler()->invokeAll('search_api_data_type_info');
    $types = $types ? $types : array();
    foreach ($types as &$type_info) {
      if (!isset($type_info['fallback']) || !isset($default_types[$type_info['fallback']])) {
        $type_info['fallback'] = 'string';
      }
    }
    \Drupal::moduleHandler()->alter('search_api_data_type_info', $types);
  }
  if (isset($type)) {
    return isset($types[$type]) ? $types[$type] : NULL;
  }
  return $types;
}

/**
 * Extracts specific field values from typed data object.
 *
 * Used during indexing.
 *
 * @param \Drupal\Core\TypedData\ComplexDataInterface $item
 *   The item from which fields should be extracted.
 * @param array $fields
 *   The fields to extract, as stored in an index. I.e., the array keys are
 *   field names, the values are arrays with at least a "type" key present.
 *   Passed by reference, "value" and "original_type" keys will be added for all
 *   fields.
 */
function search_api_extract_fields(ComplexDataInterface $item, array &$fields) {
  // Figure out which fields are directly on the item and which need to be
  // extracted from nested items.
  $direct_fields = array();
  $nested_fields = array();
  foreach (array_keys($fields) as $key) {
    if (strpos($key, ':') !== FALSE) {
      list($direct, $nested) = explode(':', $key, 2);
      $nested_fields[$direct][$nested] = &$fields[$key];
    }
    else {
      $direct_fields[] = $key;
    }
  }
  // Extract the direct fields.
  foreach ($direct_fields as $key) {
    try {
      $item = $item->get($key);
      // @todo Figure out what to do with that.
    }
    catch (\InvalidArgumentException $e) {
      // Set defaults if something fails.
      $fields[$key]['value'] = NULL;
      $fields[$key]['original_type'] = $fields[$key]['type'];
    }
  }
  // Recurse for all nested fields.
  foreach ($nested_fields as $direct => $fields_nested) {
    $success = FALSE;
    try {
      $item_nested = $item->get($direct);
      if ($item_nested instanceof ComplexDataInterface && !$item_nested->isEmpty()) {
        search_api_extract_fields($item_nested, $fields_nested);
        $success = TRUE;
      }
    }
    catch (\InvalidArgumentException $e) {
      // Will be automatically handled because $success == FALSE.
    }
    // If the values couldn't be extracted from the nested item, we have to
    // set the defaults here.
    if (!$success) {
      foreach (array_keys($fields_nested) as $key) {
        $fields[$key]['value'] = NULL;
        $fields[$key]['original_type'] = $fields[$key]['type'];
      }
    }
  }
}

/**
 * Adds an entry into a server's list of pending tasks.
 *
 * @param \Drupal\search_api\Server\ServerInterface $server
 *   The server for which a task should be remembered.
 * @param $type
 *   The type of task to perform.
 * @param \Drupal\search_api\Index\IndexInterface|string|null $index
 *   (optional) If applicable, the index to which the task pertains (or its
 *   machine name).
 * @param mixed $data
 *   (optional) If applicable, some further data necessary for the task.
 */
function search_api_server_tasks_add(ServerInterface $server, $type, $index = NULL, $data = NULL) {
  db_insert('search_api_task')
    ->fields(array(
      'server_id' => $server->id(),
      'type' => $type,
      'index_id' => $index ? (is_object($index) ? $index->id() : $index) : NULL,
      'data' => isset($data) ? serialize($data) : NULL,
    ))
    ->execute();
}

/**
 * Removes pending server tasks from the list.
 *
 * @param array|null $ids
 *   (optional) The IDs of the pending server tasks to delete. Set to NULL
 *   to not filter by IDs.
 * @param \Drupal\search_api\Server\ServerInterface|null $server
 *   (optional) A server for which the tasks should be deleted. Set to NULL to
 *   delete tasks from all servers.
 * @param \Drupal\search_api\Index\IndexInterface|string|null $index
 *   (optional) An index (or its machine name) for which the tasks should be
 *   deleted. Set to NULL to delete tasks for all indexes.
 */
function search_api_server_tasks_delete(array $ids = NULL, ServerInterface $server = NULL, $index = NULL) {
  $delete = db_delete('search_api_task');
  if ($ids) {
    $delete->condition('id', $ids);
  }
  if ($server) {
    $delete->condition('server_id', $server->id());
  }
  if ($index) {
    $delete->condition('index_id', is_object($index) ? $index->id() : $index);
  }
  $delete->execute();
}

/**
 * Implements hook_theme().
 */
function search_api_theme() {
  $themes = array();

  $themes['search_api_admin_fields_table'] = array(
    'render element' => 'element',
  );

  $themes['search_api_server'] = array(
    'variables' => array(
      'server' => NULL,
      'indexes' => array(),
    ),
  );

  $themes['search_api_index'] = array(
    'variables' => array(
      'index' => NULL,
    ),
  );

  return $themes;
}

/**
 * Returns HTML for a field list form.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the form.
 */
function theme_search_api_admin_fields_table($variables) {
  $form = $variables['element'];
  $header = array(t('Field'), t('Machine name'), t('Indexed'), t('Type'), t('Boost'));

  $rows = array();
  if (!empty($form['fields'])) {
    foreach (\Drupal\Core\Render\Element::children($form['fields']) as $name) {
      $row = array();
      foreach (\Drupal\Core\Render\Element::children($form['fields'][$name]) as $field) {
        if ($cell = render($form['fields'][$name][$field])) {
          $row[] = $cell;
        }
      }
      if (empty($form['fields'][$name]['description']['#value'])) {
        $rows[] = _search_api_deep_copy($row);
      }
      else {
        $rows[] = array(
          'data' => $row,
          'title' => strip_tags($form['fields'][$name]['description']['#value']),
        );
      }
    }
  }

  $note = isset($form['note']) ? $form['note'] : '';
  $submit = $form['submit'];
  $additional = isset($form['additional']) ? $form['additional'] : FALSE;
  unset($form['note'], $form['submit'], $form['additional']);
  $output = drupal_render_children($form);

  $build = array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
  );

  $output .= drupal_render($build);
  $output .= render($note);
  $output .= render($submit);
  if ($additional) {
    $output .= render($additional);
  }

  return $output;
}

/**
 * Returns HTML for a Search API server.
 * 
 * @param array $variables
 *   An associative array containing:
 *     - server:  A ServerInterface instance.
 *     - indexes: A renderable array which contain links to indexes associated
 *                with the server.
 *
 * @return string
 *   The rendered HTML for a Search API server.
 */
function theme_search_api_server($variables) {
  // Get the Search API server and index links.
  $server = $variables['server'];
  $indexes = $variables['indexes'];
  // Initialize the output variable to an empty string.
  $output = '';

  // Check if a description is available.
  if (($description = $server->getDescription())) {
    // Sanitiaze the description and append to the output.
    $output .= '<p class="description">' . nl2br(String::checkPlain($description)) . '</p>';
  }

  // Initialize the rows variable which will hold the different parts of server
  // information.
  $rows = array();
  // Create a row template with references so we don't have to deal with the
  // complicated structure for each inidividual row.
  $row = array(
    'data' => array(
      array('header' => TRUE),
      '',
    ),
    'class' => array(''),
  );
  // Get the individual parts of the row by reference.
  $label = &$row['data'][0]['data'];
  $info = &$row['data'][1];
  $class = &$row['class'][0];

  // Check if the server is enabled.
  if ($server->status()) {
    $class = 'ok';
    $info = t('enabled (!disable_link)', array('!disable_link' => l(t('disable'), $server->url('disable'))));
  }
  else {
    $class = 'warning';
    // Build the enable bypass url options.
    $url_options = array('query' => array('token' => \Drupal::csrfToken()->get($server->id())));
    // Build the disabled message and use the enable bypass link.
    $info = t('disabled (!enable_link)', array('!enable_link' => l(t('enabled'), $server->url('enable-bypass', $url_options))));
  }
  // Append the row and reset variables.
  $label = t('Status');
  $rows[] = _search_api_deep_copy($row);
  $class = '';

  // Check if the service used by the server is valid.
  if ($server->hasValidService()) {
    // Get the service used by the server.
    $service = $server->getService();
    // Get the service plugin definition.
    $service_plugin_definition = $service->getPluginDefinition();
    // Use the label defined in the plugin definition.
    $info = String::checkPlain($service_plugin_definition['label']);
  }
  else {
    $class = 'error';
    $info = t('Invalid or missing service plugin');
  }
  // Append the row and reset variables.
  $label = t('Service class');
  $rows[] = _search_api_deep_copy($row);
  $class = '';

  // Check if the indexes variable contains links.
  if (!empty($indexes['#links'])) {
    $label = t('Search indexes');
    $info = render($indexes);
    $rows[] = _search_api_deep_copy($row);
  }

  // Check if the server has available view settings.
  if (($options = $server->viewSettings())) {
    $label = t('Service options');
    $info = render($options);
    $rows[] = _search_api_deep_copy($row);
  }

  //
  // @todo: Add extra information once the function is available.
  //
  // Build the server info table theme variables.
  $server_info_table = array(
    '#theme' => 'table',
    '#rows' => $rows,
    '#attributes' => array(
      'class' => array(
        'search-api-summary',
        'search-api-server-summary',
        'system-status-report',
      ),
    ),
  );
  // Render the server info table and append to the output.
  $output .= drupal_render($server_info_table);

  return $output;
}

/**
 * Returns HTML for a Search API index.
 * 
 * @param array $variables
 *   An associative array containing:
 *     - index: An IndexInterface instance.
 * 
 * @return string
 *   The rendered HTML for a Search API index.
 */
function theme_search_api_index($variables) {
  // Get the Search API index
  $index = $variables['index'];
  $server = $index->hasValidServer() ? $index->getServer() : NULL;
  $datasource = $index->hasValidDatasource() ? $index->getDatasource() : NULL;
  // Initialize the output variable to an empty string.
  $output = '';

  // Check if a description is available.
  if (($description = $index->getDescription())) {
    // Sanitiaze the description and append to the output.
    $output .= '<p class="description">' . nl2br(String::checkPlain($description)) . '</p>';
  }

  // Initialize the rows variable which will hold the different parts of server
  // information.
  $rows = array();
  // Create a row template with references so we don't have to deal with the
  // complicated structure for each inidividual row.
  $row = array(
    'data' => array(
      array('header' => TRUE),
      '',
    ),
    'class' => array(''),
  );
  // Get the individual parts of the row by reference.
  $label = &$row['data'][0]['data'];
  $info = &$row['data'][1];
  $class = &$row['class'][0];

  // Check if the index is enabled.
  if ($index->status()) {
    $class = 'ok';
    $info = t ('enabled (!disable_link)', array ('!disable_link' => l (t ('disable'), $index->url ('disable'))));
  }
  // Check if a server is available and enabled.
  elseif ($server && $server->status()) {
    $class = 'warning';
    // Build the enable bypass url options.
    $url_options = array('query' => array('token' => \Drupal::csrfToken()->get($index->id())));
    // Build the disabled message and use the enable bypass link.
    $info = t('disabled (!enabled_link)', array('!enabled_link' => l(t('enable'), $index->url('enable-bypass', $url_options))));
  }
  else {
    $class = 'warning';
    $info = t('disabled');
  }
  // Append the row and reset variables.
  $label = t('Status');
  $rows[] = _search_api_deep_copy($row);
  $class = '';

  // Check if a datasource is available.
  if ($datasource) {
    // Get the datasource plugin definition.
    $datasource_plugin_definition = $datasource->getPluginDefinition();
    // Use the label defined in the plugin definition.
    $info = $datasource_plugin_definition['label'];
  }
  else {
    $class = 'error';
    $info = t('Invalid or missing datasource plugin');
  }
  // Append the row and reset variables.
  $label = t('Item type');
  $rows[] = _search_api_deep_copy($row);
  $class = '';

  // Check if a server is available.
  if ($server) {
    $label = t('Server');
    $info = l($server->label(), $server->url('canonical'));
    $rows[] = _search_api_deep_copy($row);
  }

  // Check if the index is enabled and a datasource is available.
  if ($index->status() && $datasource) {
    // Get the configured options, merge in default options to prevent notice
    // when an index is missing the required options.
    $options = $index->getOptions() + array('cron_limit' => SEARCH_API_DEFAULT_CRON_LIMIT);
    // Check if the cron limit is higher then zero.
    if ($options['cron_limit'] > 0) {
      $class = 'ok';
      $info = \Drupal::translation()->formatPlural($options['cron_limit'], 'During cron runs, 1 item will be indexed per batch.', 'During cron runs, @count items will be indexed per batch.');
    }
    else {
      $class = 'warning';
      $info = t('No items will be indexed during cron runs.');
    }
    // Append the row and reset variables.
    $label = t('Cron batch size');
    $rows[] = _search_api_deep_copy($row);
    $class = '';
    //
    // @todo: Get server status info.
    //
    // @todo: Get index status info.
    // 
    // Build the index progress bar.
    $index_progress = array(
      '#theme' => 'progress_bar',
      '#percent' => 0,
      '#message' => t('@indexed/@total indexed', array('@indexed' => 0, '@total' => 0)),
    );
    // Add the progress bar to the output.
    $output .= '<h3>' . t('Index status') . '</h3>';
    $output .= '<div class="search-api-index-status">' . drupal_render($index_progress) . '</div>';
  }

  // Build the index info table theme variables.
  $index_info_table = array(
    '#theme' => 'table',
    '#rows' => $rows,
    '#attributes' => array(
      'class' => array(
        'search-api-summary',
        'search-api-index-summary',
        'system-status-report',
      ),
    ),
  );
  // Render the server info table and append to the output.
  $output .= drupal_render($index_info_table);

  return $output;
}

/**
 * Returns a deep copy of the input array.
 *
 * The behavior of PHP regarding arrays with references pointing to it is rather
 * weird. Therefore, we use this helper function in theme_search_api_index() to
 * create safe copies of such arrays.
 *
 * @param array $array
 *   The array to copy.
 *
 * @return array
 *   A deep copy of the array.
 */
function _search_api_deep_copy(array $array) {
  $copy = array();
  foreach ($array as $k => $v) {
    if (is_array($v)) {
      $copy[$k] = _search_api_deep_copy($v);
    }
    elseif (is_object($v)) {
      $copy[$k] = clone $v;
    }
    elseif ($v) {
      $copy[$k] = $v;
    }
  }
  return $copy;
}

/**
 * Custom sort function for the processors
 *
 * @param $processor_setting_a
 * @param $processor_setting_b
 * @return int
 */
function _search_api_sort_processors($processor_setting_a, $processor_setting_b) {
  if ($processor_setting_a['weight'] == $processor_setting_b['weight']) {
    return 0;
  }
  return ($processor_setting_a['weight'] < $processor_setting_b['weight']) ? -1 : 1;
}
