<?php
// $Id$

/**
 * Default number of items indexed at each cron run for each enabled index.
 */
define('SEARCH_API_DEFAULT_CRON_LIMIT', 50);

/**
 * Implements hook_cron().
 *
 * Will index $options['cron-limit'] items for each enabled index.
 */
function search_api_cron() {
  foreach (search_api_list_indexes() as $index) {
    $limit = isset($index->options['cron_limit'])
        ? $index->options['cron_limit']
        : SEARCH_API_DEFAULT_CRON_LIMIT;
    if ($limit) {
      $num = search_api_index_items($index, $limit);
      if ($num) {
        watchdog('search_api', t('Indexed !num items for index !name',
            array('!num' => $num, '!name' => $index->name)), NULL,
            WATCHDOG_INFO);
      }
    }
  }
}

/**
 * Implements hook_entity_insert().
 *
 * Marks the new item as to-index for all indexes on entities of the specified
 * type.
 */
function search_api_entity_insert($entity, $type) {
  $id = entity_get_info($type);
  foreach (search_api_list_indexes(array('entity_type' => $type)) as $index) {
    db_insert('search_api_item')
      ->fields(array(
        'item_id' => $entity->$id,
        'index_id' => $index->id,
        'changed' => 1,// Set always to 1 to index new items before changed ones
      ))
      ->execute();
  }
}

/**
 * Implements hook_entity_update().
 *
 * Marks the item as changed for all indexes on entities of the specified type.
 */
function search_api_entity_update($entity, $type) {
  $id = entity_get_info($type);
  foreach (search_api_list_indexes(array('entity_type' => $type)) as $index) {
    db_update('search_api_item')
      ->fields(array(
        'changed' => REQUEST_TIME,
      ))
      ->condition('item_id', $entity->$id)
      ->condition('index_id', $index->id)
      ->condition('changed', 0)
      ->execute();
  }
}

/**
 * Implements hook_search_api_register_alter_callback().
 */
function search_api_search_api_register_alter_callback() {
  $callbacks['search_api_alter_prepare_view'] = array(
    'name' => t('Call hook'),
    'description' =>
        t('Calls the standard entity_prepare_view() function for all items.'),
    'weight' => -10,
  );

  return $callbacks;
}

/**
 * Indexes items for the specified index. Only items marked as changed are
 * indexed, in their order of change (if known).
 *
 * @param $index The index on which items should be indexed.
 * @param $limit The number of items which should be indexed at most.
 *
 * @return Number of successfully indexed items, or FALSE if an error occurred.
 */
function search_api_index_items($index, $limit) {
  $entity_info = entity_get_info($index->entity_type);
  // Safety check if entity type is known (prevent failing of whole cron run)
  if (!$entity_info) {
    watchdog('search_api', t("Couldn't index values for '!name' index " .
        "(unknown entity type '!type')", array('!name' => $index->name,
        '!type' => $index->entity_type)), NULL, WATCHDOG_ERROR);
    return FALSE;
  }

  $backend = search_api_backend_load($index->backend);
  if (!$backend) {
    watchdog('search_api', t("Couldn't index values for '!name' index " .
        '(backend could not be retrieved)', array('!name' => $index->name)),
        NULL, WATCHDOG_ERROR);
    return FALSE;
  }

  $items = search_api_get_items_to_index($index, $limit);
  if (!$items) {
    return 0;
  }
  search_api_item_data_alter('index', $index, $items);
  if (!$items) {
    return 0;
  }
  search_api_item_preprocess('index', $index, $items);
  $indexed = $backend->index($index, $items);

  if (!empty($indexed)) {
    search_api_set_items_indexed($index, $indexed);
  }

  return count($indexed);
}

/**
 * Returns a list of at most $limit items that need to be indexed for the
 * specified index.
 *
 * @param $index The index for which items should be retrieved.
 * @param $limit The maximum number of items to retrieve. -1 means no limit.
 *
 * @return An array of items (entities) that need to be indexed.
 */
function search_api_get_items_to_index($index, $limit = -1) {
  if ($limit == 0) {
    return array();
  }
  $select = db_select('search_api_item', 'i');
  $select->addField('i', 'item_id');
  $select->condition('index_id', $index->id);
  $select->condition('changed', 0, '<>');
  $select->orderBy('changed', 'ASC');
  if ($limit > 0) {
    $select->range(0, $limit);
  }

  $ids = $select->execute()->fetchCol();
  return entity_load($index->entity_type, $ids);
}

/**
 * Calls data alteration hooks for a set of items, according to the index
 * options.
 *
 * @param $phase The phase in which this call occurs. Either 'index' or
 *   'search'.
 * @param $index The index on which the items are indexed.
 * @param $items An array of items to be altered.
 */
function search_api_item_data_alter($phase, $index, &$items) {
  if (empty($index['options']['data_alter_callbacks'])) {
    return;
  }

  foreach ($index['options']['data_alter_callbacks'] as $func) {
    $func($phase, $index, &$items);
    if (empty($items)) {
      return;
    }
  }
}

/**
 * Runs all preprocessors that are activated for the specified index on the
 * given items.
 *
 * @param $phase The phase in which this call occurs. Either 'index' or
 *   'search'.
 * @param $index The index on which the items are indexed.
 * @param $items An array of items to be preprocessed.
 */
function search_api_item_preprocess($phase, $index, &$items) {
  // @todo
}

/**
 * Runs all postprocessors that are activated for the specified index on the
 * given items.
 *
 * @param $index The index on which the items are indexed.
 * @param $items An array of items to be postprocessed.
 */
function search_api_item_postprocess($index, &$items) {
  // @todo
}

/**
 * Marks the items as successfully indexed for the specified index.
 *
 * @param $index The index on which items were indexed.
 * @param $ids The ids of the indexed items.
 *
 * @return The number of index entries changed.
 */
function search_api_set_items_indexed($index, $ids) {
  return db_update('search_api_item')
      ->fields(array(
        'changed' => 0,
      ))
      ->condition('index_id', $index->id)
      ->condition('item_id', $ids, 'IN')
      ->execute();
}

/**
 * Search API data alteration callback that calls entity_prepare_view() for all
 * items.
 *
 * @param $phase The phase in which this call occurs. Either 'index' or
 *   'search'.
 * @param $index The index on which the items are indexed.
 * @param $items An array of objects containing the entity data.
 */
function search_api_alter_prepare_view($phase, $index, &$items) {
  entity_prepare_view($index->entity_type, $items);
}

/**
 * Returns either a list of all available backend classes, or a specific one.
 *
 * @param $id The id of the backend class to retrieve.
 *
 * @return If $id was not specified, an array of all available backend classes.
 *   Otherwise, either the backend class with the specified id (if it exists),
 *   or NULL.
 */
function search_api_get_backend_class($id = NULL) {
  $backends = &drupal_static(__FUNCTION__);

  if (!isset($backends)) {
    $backends = module_invoke_all('search_api_backends');

    // Initialization of optional entries with default values
    foreach ($backends as $id => $backend) {
      if (!isset($backend['class'])) {
        $backends[$id]['class'] = $id;
      }
      if (!isset($backend['init args'])) {
        $backends[$id]['init args'] = array();
      }
    }
  }

  if (isset($id)) {
    return isset($backends[$id]) ? $backends[$id] : NULL;
  }
  return $backends;
}

/**
 * Returns a list of all (enabled) search backends.
 *
 * @param $enabled Whether to retrieve only enabled backends.
 *
 * @return An array of objects representing all (or, if $enabled is TRUE, only
 *   enabled) search backends.
 */
function search_api_list_backends($enabled = TRUE) {
  $backends = &drupal_static(__FUNCTION__);

  $enabled = (int) $enabled;
  if (!isset($backends[$enabled])) {
    $select = db_select('search_api_backend', 's')->fields('s');
    if ($enabled) {
      $select->condition('s.enabled', 1);
    }

    $results = $select->execute();
    $backends[$enabled] = array();
    foreach ($results as $row) {
      $row->options = unserialize($row->options);
      $backends[$enabled][$row->id] = $row;
    }
  }

  return $backends[$enabled];
}

/**
 * Load the search backend with the specified id.
 *
 * @param $id The search backend's id.
 *
 * @return The loaded and initialized SearchApiBackend object representing the
 *   backend with the specified id.
 */
function search_api_backend_load($id) {
  $backends = &drupal_static(__FUNCTION__);

  if (!isset($backends[$id])) {
    //@todo This won't work if backend classes needn't have the class name as id
    $ret = db_query('SELECT class, id, name, description, options, enabled ' .
        'FROM {search_api_backend} WHERE id = :id', array(':id' => (int) $id))
        ->fetch(PDO::FETCH_CLASS | PDO::FETCH_CLASSTYPE);
    if (!$ret) {
      watchdog('search_api', t('Unknown search backend with id @id',
          array('@id' => $id)), NULL, WATCHDOG_WARNING);
      $ret = FALSE;
    }
    else if (!($ret instanceof SearchApiBackend)) {
      // @todo Add link to backend configuration once admin pages are implemented
      watchdog('search_api',
          t('Backend with id @id specifies illegal backend class @class',
          array('@id' => $id, '@class' => $ret->class)), NULL, WATCHDOG_ERROR);
      $ret = FALSE;
    }
    else {
      $ret->options = unserialize($ret->options);
      $ret->init($ret->options);
    }

    $backends[$id] = $ret;
  }

  return $backends[$id] ? $backends[$id] : NULL;
}

/**
 * Returns a list of search indexes.
 *
 * @param $options An associative array of conditions on the returned indexes.
 *   - enabled: Unless set to FALSE, only enabled indexes will be returned.
 *   - backend: Return only indexes on the backend with the specified id.
 *
 * @return An array of objects representing the search indexes that meet the
 *   specified criteria.
 */
function search_api_list_indexes(array $options = array()) {
  $enabled = isset($options['enabled']) && !$options['enabled'] ? 0 : 1;
  $backend = empty($options['backend']) ? NULL : $options['backend'];
  $type = empty($options['entity_type']) ? NULL : $options['entity_type'];

  $select = db_select('search_api_index', 'i')->fields('i');
  if ($enabled) {
    $select->condition('i.enabled', 1);
  }
  if (!empty($backend)) {
    $select->condition('i.backend', $backend);
  }
  if (!empty($type)) {
    $select->condition('i.entity_type', $type);
  }

  $results = $select->execute();
  $indexes = array();
  foreach ($results as $row) {
    $row->options = unserialize($row->options);
    $indexes[$row->id] = $row;
  }

  return $indexes;
}


function search_api_index_load($id) {
  $result = db_query('SELECT * FROM {search_api_index} WHERE id = :id',
      array(':id' => (int) $id))->fetchObject();
  if (!$result) {
    watchdog('search_api', t('Unknown search index with id @id',
        array('@id' => $id)), NULL, WATCHDOG_WARNING);
    return NULL;
  }
  $result->options = unserialize($result->options);

  return $result;
}
