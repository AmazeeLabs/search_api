<?php
/**
 * @file
 * Contains the Search API hook implementations.
 */

use Drupal\Core\Entity\ContentEntityType;
use Drupal\Core\Entity\EntityInterface;

/*
 * Constant definitions.
 */

/**
 * Default number of items indexed per cron batch for each enabled index.
 */
define('SEARCH_API_DEFAULT_CRON_LIMIT', 50);

/*
 * Hook implementations.
 */

/**
 * Implements hook_menu_link_defaults().
 */
function search_api_menu_link_defaults() {
  return array(
    'search_api.overview' => array(
      'link_title' => 'Search API',
      'description' => 'Create and configure search engines.',
      'route_name' => 'search_api.overview',
      'parent' => 'system.admin_config_search',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function search_api_permission() {
  return array(
    'administer search_api' => array(
      'title' => t('Administer Search API'),
      'description' => t('Create and configure Search API servers and indexes.'),
    ),
  );
}

/**
 * Implements hook_entity_insert().
 */
function search_api_entity_insert(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity insert.
  }
}

/**
 * Implements hook_entity_update().
 */
function search_api_entity_update(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity change.
  }
}

/**
 * Implements hook_entity_delete().
 */
function search_api_entity_delete(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity delete.
  }
}

/**
 * Determines whether a field of the given type contains text data.
 *
 * @param string $type
 *   A string containing the type to check.
 * @param array $allowed
 *   Optionally, an array of allowed types.
 *
 * @return bool
 *   TRUE if $type is either one of the specified types, or a list of such
 *   values. FALSE otherwise.
 */
function search_api_is_text_type($type, array $allowed = array('text')) {
  return in_array($type, $allowed);
}

/**
 * Checks whether it is possible to sort on fields of the given type.
 *
 * @param $type
 *   The type to check for.
 *
 * @todo
 *   Make sure you take the field object and check the isMultiple parameter
 *
 * @return bool
 *   TRUE if this type is sortable, FALSE otherwise.
 */
function search_api_is_sortable_type($type) {
  return !search_api_is_text_type($type);
}

/**
 * Returns all field types recognized by the Search API framework.
 *
 * @return array
 *   An associative array with all recognized types as keys, mapped to their
 *   translated display names.
 *
 * @see search_api_default_field_types()
 * @see search_api_get_data_type_info()
 */
function search_api_field_types() {
  $types = search_api_default_field_types();
  foreach (search_api_get_data_type_info() as $id => $type) {
    $types[$id] = $type['name'];
  }
  return $types;
}

/**
 * Returns the default field types recognized by the Search API framework.
 *
 * @return array
 *   An associative array with the default types as keys, mapped to their
 *   translated display names.
 */
function search_api_default_field_types() {
  return array(
    'text' => t('Fulltext'),
    'string' => t('String'),
    'integer' => t('Integer'),
    'decimal' => t('Decimal'),
    'date' => t('Date'),
    'duration' => t('Duration'),
    'boolean' => t('Boolean'),
    'uri' => t('URI'),
    'language' => t('Language'),
    'uuid' => t('UUID'),
    'timestamp' => t('Timestamp'),
    'path' => t('Path'),
    'text_with_summary' => t('Text with summary'),
    'comment' => t('Comment'),
  );
}

/**
 * Returns either all custom field type definitions, or a specific one.
 *
 * @param $type
 *   If specified, the type whose definition should be returned.
 *
 * @return array
 *   If $type was not given, an array containing all custom data types, in the
 *   format specified by hook_search_api_data_type_info().
 *   Otherwise, the definition for the given type, or NULL if it is unknown.
 *
 * @see hook_search_api_data_type_info()
 */
function search_api_get_data_type_info($type = NULL) {
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    $default_types = search_api_default_field_types();
    $types =  \Drupal::moduleHandler()->invokeAll('search_api_data_type_info');
    $types = $types ? $types : array();
    foreach ($types as &$type_info) {
      if (!isset($type_info['fallback']) || !isset($default_types[$type_info['fallback']])) {
        $type_info['fallback'] = 'string';
      }
    }
    \Drupal::moduleHandler()->alter('search_api_data_type_info', $types);
  }
  if (isset($type)) {
    return isset($types[$type]) ? $types[$type] : NULL;
  }
  return $types;
}

/**
 * Extracts specific field values from an EntityMetadataWrapper object.
 *
 * @see Drupal\search_api\Plugin\SearchApi\Processor\Highlight::getFulltextfields()
 * @todo
 */
function search_api_extract_fields($wrapper, array $fields, array $value_options = array()) {
  return array();
}

/**
 * Returns HTML for a field list form.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the form.
 */
function theme_search_api_admin_fields_table($variables) {
  $form = $variables['element'];
  $header = array(t('Field'), t('Machine name'), t('Indexed'), t('Type'), t('Boost'));

  $rows = array();
  foreach (\Drupal\Core\Render\Element::children($form['fields']) as $name) {
    $row = array();
    foreach (\Drupal\Core\Render\Element::children($form['fields'][$name]) as $field) {
      if ($cell = render($form['fields'][$name][$field])) {
        $row[] = $cell;
      }
    }
    if (empty($form['fields'][$name]['description']['#value'])) {
      $rows[] = _search_api_deep_copy($row);
    }
    else {
      $rows[] = array(
        'data' => $row,
        'title' => strip_tags($form['fields'][$name]['description']['#value']),
      );
    }
  }

  $note = isset($form['note']) ? $form['note'] : '';
  $submit = $form['submit'];
  $additional = isset($form['additional']) ? $form['additional'] : FALSE;
  unset($form['note'], $form['submit'], $form['additional']);
  $output = drupal_render_children($form);
  $output .= theme('table', array('header' => $header, 'rows' => $rows));
  $output .= render($note);
  $output .= render($submit);
  if ($additional) {
    $output .= render($additional);
  }

  return $output;
}

/**
 * Returns a deep copy of the input array.
 *
 * The behavior of PHP regarding arrays with references pointing to it is rather
 * weird. Therefore, we use this helper function in theme_search_api_index() to
 * create safe copies of such arrays.
 *
 * @param array $array
 *   The array to copy.
 *
 * @return array
 *   A deep copy of the array.
 */
function _search_api_deep_copy(array $array) {
  $copy = array();
  foreach ($array as $k => $v) {
    if (is_array($v)) {
      $copy[$k] = _search_api_deep_copy($v);
    }
    elseif (is_object($v)) {
      $copy[$k] = clone $v;
    }
    elseif ($v) {
      $copy[$k] = $v;
    }
  }
  return $copy;
}
