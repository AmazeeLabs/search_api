<?php
/**
 * @file
 * Contains the Search API hook implementations.
 */

use Drupal\Core\Entity\ContentEntityType;
use Drupal\Core\Entity\EntityInterface;

/*
 * Constant definitions.
 */

/**
 * Default number of items indexed per cron batch for each enabled index.
 */
define('SEARCH_API_DEFAULT_CRON_LIMIT', 50);

/*
 * Hook implementations.
 */

/**
 * Implements hook_menu_link_defaults().
 */
function search_api_menu_link_defaults() {
  return array(
    'search_api.overview' => array(
      'link_title' => 'Search API',
      'description' => 'Create and configure search engines.',
      'route_name' => 'search_api.overview',
      'parent' => 'system.admin_config_search',
    ),
    'search_api.server_overview' => array(
      'link_title' => 'Servers',
      'description' => 'Create and configure search servers.',
      'route_name' => 'search_api.server_overview',
      'parent' => 'search_api.overview',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function search_api_permission() {
  return array(
    'administer search_api' => array(
      'title' => t('Administer Search API'),
      'description' => t('Create and configure Search API servers and indexes.'),
    ),
  );
}

/**
 * Implements hook_entity_insert().
 */
function search_api_entity_insert(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity insert.
  }
}

/**
 * Implements hook_entity_update().
 */
function search_api_entity_update(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity change.
  }
}

/**
 * Implements hook_entity_delete().
 */
function search_api_entity_delete(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity delete.
  }
}

/**
 * Determines whether a field of the given type contains text data.
 *
 * @param string $type
 *   A string containing the type to check.
 * @param array $allowed
 *   Optionally, an array of allowed types.
 *
 * @return bool
 *   TRUE if $type is either one of the specified types, or a list of such
 *   values. FALSE otherwise.
 */
function search_api_is_text_type($type, array $allowed = array('text')) {
  return in_array(search_api_extract_inner_type($type), $allowed);
}

/**
 * Determines whether a field of the given type contains a list of any kind.
 *
 * @param string $type
 *   A string containing the type to check.
 *
 * @return bool
 *   TRUE iff $type is a list type ("list<*>").
 */
function search_api_is_list_type($type) {
  return substr($type, 0, 5) == 'list<';
}

/**
 * Determines the nesting level of a list type.
 *
 * @param string $type
 *   The type to check.
 *
 * @return int
 *   The nesting level of the type. 0 for singular types, 1 for lists of
 *   singular types, etc.
 */
function search_api_list_nesting_level($type) {
  $level = 0;
  while (search_api_is_list_type($type)) {
    $type = substr($type, 5, -1);
    ++$level;
  }
  return $level;
}

/**
 * Nests a type to the same level as another type.
 *
 * I.e., after
 * @code
 * $t = search_api_nest_type($type, $nested_type);
 * @endcode
 * is executed, the following statements will always be true:
 *
 * @code
 * search_api_list_nesting_level($t) == search_api_list_nesting_level($nested_type);
 * search_api_extract_inner_type($t) == search_api_extract_inner_type($type);
 * @endcode
 *
 * @param string $type
 *   The type to wrap.
 * @param string $nested_type
 *   Another type, determining the nesting level.
 *
 * @return string
 *   A list version of $type, as specified above.
 */
function search_api_nest_type($type, $nested_type) {
  while (search_api_is_list_type($nested_type)) {
    $nested_type = substr($nested_type, 5, -1);
    $type = "list<$type>";
  }
  return $type;
}

/**
 * Extracts the contained primitive type of a list type.
 *
 * @param string $type
 *   A string containing the list type to process.
 *
 * @return string
 *   A string containing the primitive type contained within the list, e.g.
 *   "text" for "list<text>" (or for "list<list<text>>"). If $type is no list
 *   type, it is returned unchanged.
 */
function search_api_extract_inner_type($type) {
  while (search_api_is_list_type($type)) {
    $type = substr($type, 5, -1);
  }
  return $type;
}

/**
 * Checks whether it is possible to sort on fields of the given type.
 *
 * @param $type
 *   The type to check for.
 *
 * @return bool
 *   TRUE if this type is sortable, FALSE otherwise.
 */
function search_api_is_sortable_type($type) {
  return !search_api_is_text_type($type) && !search_api_is_list_type($type);
}
