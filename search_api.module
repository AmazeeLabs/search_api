<?php
// $Id$

/**
 * Default number of items indexed at each cron run for each enabled index.
 */
define('SEARCH_API_DEFAULT_CRON_LIMIT', 50);

/**
 * Implements hook_menu().
 */
function search_api_menu() {
  $pre = 'admin/config/search/search_api';
  $items[$pre] = array(
    'title' => 'Search API',
    'description' => 'Create and configure search engines.',
    'page callback' => 'search_api_admin_overview',
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
  );
  $items[$pre . '/overview'] = array(
    'title' => 'Overview',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items[$pre . '/add_server'] = array(
    'title' => 'Add server',
    'description' => 'Create a new search server.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_add_server'),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'weight' => -1,
    'type' => MENU_LOCAL_ACTION,
  );
  $items[$pre . '/add_index'] = array(
    'title' => 'Add index',
    'description' => 'Create a new search index.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_add_index'),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items[$pre . '/server/%search_api_server'] = array(
    'title' => 'View server',
    'title callback' => 'search_api_admin_item_title',
    'title arguments' => array(5),
    'description' => 'View server details.',
    'page callback' => 'search_api_admin_server_view',
    'page arguments' => array(5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items[$pre . '/server/%search_api_server/view'] = array(
    'title' => 'View',
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items[$pre . '/server/%search_api_server/edit'] = array(
    'title' => 'Edit',
    'description' => 'Edit server details.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_server_edit', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/server/%search_api_server/delete'] = array(
    'title' => 'Delete',
    'description' => 'Delete server.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_confirm', 'server', 'delete', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/index/%search_api_index'] = array(
    'title' => 'View index',
    'title callback' => 'search_api_admin_item_title',
    'title arguments' => array(5, 6),
    'description' => 'View index details.',
    'page callback' => 'search_api_admin_index_view',
    'page arguments' => array(5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items[$pre . '/index/%search_api_index/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items[$pre . '/index/%search_api_index/status'] = array(
    'title' => 'Status',
    'description' => 'Display and work on index status.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_index_status_form', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'weight' => -8,
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/index/%search_api_index/edit'] = array(
    'title' => 'Settings',
    'description' => 'Edit index settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_index_edit', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'weight' => -6,
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/index/%search_api_index/workflow'] = array(
    'title' => 'Workflow',
    'description' => 'Edit index workflow.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_index_workflow', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'weight' => -4,
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/index/%search_api_index/fields'] = array(
    'title' => 'Fields',
    'description' => 'Select indexed fields.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_index_fields', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'weight' => -2,
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/index/%search_api_index/delete'] = array(
    'title' => 'Delete',
    'description' => 'Delete index.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_confirm', 'index', 'delete', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function search_api_theme() {
  $themes['search_api_server'] = array(
    'variables' => array(
      'id' => NULL,
      'name' => '',
      'description' => NULL,
      'enabled' => NULL,
      'class_name' => NULL,
      'class_description' => NULL,
      'options' => array(),
      'option_names' => array()
    ),
    'file' => 'search_api.admin.inc',
  );
  $themes['search_api_index'] = array(
    'variables' => array(
      'id' => NULL,
      'name' => '',
      'description' => NULL,
      'entity_type' => NULL,
      'enabled' => NULL,
      'server' => NULL,
      'options' => array(),
      'indexed_items' => 0,
      'total_items' => 0,
    ),
    'file' => 'search_api.admin.inc',
  );
  $themes['search_api_admin_item_order'] = array(
    'render element' => 'element',
    'file' => 'search_api.admin.inc',
  );
  $themes['search_api_admin_fields_table'] = array(
    'render element' => 'element',
    'file' => 'search_api.admin.inc',
  );

  return $themes;
}

/**
 * Implements hook_permission().
 */
function search_api_permission() {
  return array(
    'administer search_api' => array(
      'title' => t('Administer Search API'),
      'description' => t('Create and configure Search API servers and indexes.'),
    ),
  );
}

/**
 * Implements hook_cron().
 *
 * Will index $options['cron-limit'] items for each enabled index.
 */
function search_api_cron() {
  foreach (search_api_list_indexes() as $index) {
    $limit = isset($index->options['cron_limit'])
        ? $index->options['cron_limit']
        : SEARCH_API_DEFAULT_CRON_LIMIT;
    if ($limit) {
      try {
        $num = search_api_index_items($index, $limit);
        if ($num) {
          watchdog('search_api', t('Indexed !num items for index !name', array('!num' => $num, '!name' => $index->name)), NULL, WATCHDOG_INFO);
        }
      }
      catch (SearchApiException $e) {
        watchdog('search_api', $e->getMessage(), NULL, WATCHDOG_WARNING);
      }
    }
  }
}

/**
 * Implements hook_entity_info().
 */
function search_api_entity_info() {
  $info['search_api_server'] = array(
    'label' => t('Search server'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'SearchApiServer',
    'base table' => 'search_api_server',
    'load hook' => 'search_api_server_load',
    'uri callback' => 'search_api_server_url',
    'entity keys' => array(
      'id' => 'id',
    ),
  );
  $info['search_api_index'] = array(
    'label' => t('Search server'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'SearchApiIndex',
    'base table' => 'search_api_index',
    'load hook' => 'search_api_index_load',
    'uri callback' => 'search_api_index_url',
    'entity keys' => array(
      'id' => 'id',
    ),
  );

  return $info;
}

/**
 * Implements hook_entity_insert().
 *
 * Marks the new item as to-index for all indexes on entities of the specified
 * type.
 *
 * @param $entity
 *   The new entity.
 * @param $type
 *   The entity's type.
 */
function search_api_entity_insert($entity, $type) {
  $info = entity_get_info($type);
  $id = $info['entity keys']['id'];

  $query = db_select('search_api_index', 'i');
  $query->addField('id', 'index_id');
  $query->addExpression(':item_id', 'item_id', array(':item_id' => $entity->$id));
  $query->addExpression('1', 'changed');
  $query->condition('entity_type', $type);

  db_insert('search_api_item')
    ->from($query)
    ->execute();

  if ($type == 'search_api_server' || $type == 'search_api_index') {
    module_invoke_all($type . '_insert', $entity);
  }
}

/**
 * Implements hook_entity_update().
 *
 * Marks the item as changed for all indexes on entities of the specified type.
 *
 * @param $entity
 *   The updated entity.
 * @param $type
 *   The entity's type.
 */
function search_api_entity_update($entity, $type) {
  $info = entity_get_info($type);
  $id = $info['entity keys']['id'];

  $query = db_select('search_api_index', 'ind')
    ->fields('ind', array('id'))
    ->condition('entity_type', $type);

  db_update('search_api_item')
    ->fields(array(
      'changed' => REQUEST_TIME,
    ))
    ->condition('item_id', $entity->$id)
    ->condition('index_id', $query, 'IN')
    ->condition('changed', 0)
    ->execute();

  if ($type == 'search_api_server' || $type == 'search_api_index') {
    module_invoke_all($type . '_update', $entity, 'edit');
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Removes the item from {search_api_item} and deletes it from all indexes.
 *
 * @param $entity
 *   The updated entity.
 * @param $type
 *   The entity's type.
 */
function search_api_entity_delete($entity, $type) {
  $info = entity_get_info($type);
  $id_field = $info['entity keys']['id'];
  $id = $entity->$id_field;
  foreach (search_api_list_indexes(array('entity_type' => $type, 'only_enabled' => FALSE)) as $index) {
    db_delete('search_api_item')
      ->condition('item_id', $id)
      ->condition('index_id', $index->id)
      ->execute();
    if ($index->server) {
      $server = search_api_server_load($index->server);
      if ($server->enabled) {
        $server->deleteItems(array($id), $index);
      }
      else {
        $tasks = variable_get('search_api_tasks', array());
        $tasks[$server->id][$index->id] = array('delete-' . $id);
        variable_set('search_api_tasks', $tasks);
      }
    }
  }

  if ($type == 'search_api_server' || $type == 'search_api_index') {
    module_invoke_all($type . '_delete', $entity);
  }
}

/**
 * Implements hook_search_api_alter_callback_info().
 */
function search_api_search_api_alter_callback_info() {
  $callbacks['search_api_alter_prepare_view'] = array(
    'name' => t('Call hook'),
    'description' => t('Calls the standard entity_prepare_view() function for all items.'),
    'weight' => -10,
  );
  // @todo Add callback that adds a search_api_uri field
  // @todo Add heavy-weight callback that aggregates string fields into a search_api_fulltext field at index time

  return $callbacks;
}

/**
 * Indexes items for the specified index. Only items marked as changed are
 * indexed, in their order of change (if known).
 *
 * @param SearchApiIndex $index
 *   The index on which items should be indexed.
 * @param $limit
 *   The number of items which should be indexed at most. -1 means no limit.
 *
 * @return
 *   Number of successfully indexed items.
 */
function search_api_index_items(SearchApiIndex $index, $limit = -1) {
  $entity_info = entity_get_info($index->entity_type);
  // Safety check if entity type is known (prevent failing of whole cron run)
  if (!$entity_info) {
    throw new SearchApiException(t("Couldn't index values for '!name' index (unknown entity type '!type')", array('!name' => $index->name, '!type' => $index->entity_type)));
  }

  $server = search_api_server_load($index->server);
  if (!$server) {
    throw new SearchApiException(t("Couldn't index values for '!name' index (server info could not be retrieved)", array('!name' => $index->name)));
  }

  $items = search_api_get_items_to_index($index, $limit);
  if (!$items) {
    return 0;
  }
  search_api_item_data_alter($index, $items);
  if (!$items) {
    return 0;
  }
  search_api_item_process('pre-index', $index, $items);
  $indexed = $server->indexItems($index, $items);

  if (!empty($indexed)) {
    search_api_set_items_indexed($index, $indexed);
  }

  return count($indexed);
}

/**
 * Returns a list of at most $limit items that need to be indexed for the
 * specified index.
 *
 * @param SearchApiIndex $index
 *   The index for which items should be retrieved.
 * @param $limit
 *   The maximum number of items to retrieve. -1 means no limit.
 *
 * @return
 *   An array of items (entities) that need to be indexed.
 */
function search_api_get_items_to_index(SearchApiIndex $index, $limit = -1) {
  if ($limit == 0) {
    return array();
  }
  $select = db_select('search_api_item', 'i');
  $select->addField('i', 'item_id');
  $select->condition('index_id', $index->id);
  $select->condition('changed', 0, '<>');
  $select->orderBy('changed', 'ASC');
  if ($limit > 0) {
    $select->range(0, $limit);
  }

  $ids = $select->execute()->fetchCol();
  return entity_load($index->entity_type, $ids);
}

/**
 * Calls data alteration hooks for a set of items, according to the index
 * options.
 *
 * @param SearchApiIndex $index
 *   The index on which the items will be indexed.
 * @param array $items
 *   An array of items to be altered.
 */
function search_api_item_data_alter(SearchApiIndex $index, array &$items) {
  if (empty($index->options['data_alter_callbacks'])) {
    return;
  }

  foreach ($index->options['data_alter_callbacks'] as $func => $settings) {
    if (empty($settings['status'])) {
      continue;
    }
    if (!function_exists($func)) {
      watchdog('search_api', t('Undefined data alter callback function  !function() specified in index !name', array('!function' => $func, '!name' => $index->name)), NULL, WATCHDOG_WARNING);
      continue;
    }
    $func($index, $items);
    if (empty($items)) {
      return;
    }
  }
}

/**
 * Runs all processors that are active for the specified index on the given
 * items.
 *
 * @param $phase
 *   The phase in which this call occurs. Either 'pre-index', 'pre-search' or
 *   'post-search'.
 * @param SearchApiIndex $index
 *   The index on which the items are indexed.
 * @param array $data
 *   An array of items to be preprocessed at pre-index time, a
 *   SearchApiQueryInterface object at pre-search time, or an array of search
 *   results at post-search time.
 * @param SearchApiQueryInterface $query
 *   For the "post-search" phase, the SearchApiQueryInterface object
 *   representing the executed query.
 */
function search_api_item_process($phase, SearchApiIndex $index, &$data, SearchApiQueryInterface $query = NULL) {
  if (empty($index->options['processors'])) {
    return;
  }

  $processor_settings = $index->options['processors'];
  $processors = &drupal_static(__FUNCTION__);
  $infos = search_api_get_processors();

  if ($phase == 'post-search') {
    if (!$query) {
      throw new SearchApiException(t('No query given for postprocessing search results.'));
    }
    $processor_settings = array_reverse($processor_settings, TRUE);
  }

  foreach ($processor_settings as $id => $settings) {
    if (empty($settings['status'])) {
      continue;
    }
    if (empty($infos[$id]) || !class_exists($infos[$id]['class'])) {
      watchdog('search_api', t('Undefined preprocessor class !class specified in index !name', array('!class' => $class, '!name' => $index->name)), NULL, WATCHDOG_WARNING);
      continue;
    }
    $class = $infos[$id]['class'];
    if (empty($processors[$id])) {
      $processors[$id] = new $class(isset($settings['options']) ? $settings['options'] : array());
    }
    if (!($processors[$id] instanceof SearchApiProcessorInterface)) {
      watchdog('search_api', t('Undefined preprocessor class !class specified in index !name', array('!class' => $class, '!name' => $index->name)), NULL, WATCHDOG_WARNING);
      continue;
    }

    switch ($phase) {
      case 'pre-index':
        $processors[$id]->preprocessIndexItems($index, $data);
        break;
      case 'pre-search':
        $processors[$id]->preprocessSearchQuery($index, $data);
        break;
      case 'post-search':
        $processors[$id]->postprocessSearchResults($index, $query, $data);
        break;
      default:
        throw new SearchApiException('search_api', t('!function() called with unknown phase !phase', array('!function' => __FUNCTION__, '!phase' => $phase)));
    }
  }
}

/**
 * Marks the items as successfully indexed for the specified index.
 *
 * @param SearchApiIndex $index
 *   The index on which items were indexed.
 * @param array $ids
 *   The ids of the indexed items.
 *
 * @return
 *   The number of index entries changed.
 */
function search_api_set_items_indexed(SearchApiIndex $index, array $ids) {
  return db_update('search_api_item')
      ->fields(array(
        'changed' => 0,
      ))
      ->condition('index_id', $index->id)
      ->condition('item_id', $ids, 'IN')
      ->execute();
}

/**
 * Search API data alteration callback that calls entity_prepare_view() for all
 * items.
 *
 * @param SearchApiIndex $index
 *   The index on which the items are indexed.
 * @param $items
 *   An array of objects containing the entity data.
 */
function search_api_alter_prepare_view(SearchApiIndex $index, array &$items) {
  entity_prepare_view($index->entity_type, $items);
}

/**
 * Creates a search query on a specified search index.
 *
 * @param SearchApiIndex $index
 *   The index to execute the search on.
 * @param $options
 *   An associative array of options. The following are recognized:
 *   - filters: Either a SearchApiQueryFilterInterface object or an array of
 *     filters used to filter the search.
 *   - sort: An array of sort directives of the form $field => $order, where
 *     $order is either 'ASC' or 'DESC'.
 *   - offset: The position of the first returned search results relative to the
 *     whole result in the index.
 *   - limit: The maximum number of search results to return. -1 means no limit.
 *   - 'query class': The query class to use. Must be a subtype of
 *     SearchApiQueryInterface.
 *   - conjunction: The type of conjunction to use for this query - either
 *     'AND' or 'OR'. 'AND' by default.
 *   - 'parse mode': The mode with which to parse the $keys variable, if it
 *     is set and not already an array. See SearchApiQuery::parseModes() for
 *     parse modes recognized by the SearchApiQuery class.
 *     Subclasses might define additional modes.
 *
 * @return
 *   A SearchApiQueryInterface object for searching on the specified index.
 */
function search_api_query(SearchApiIndex $index, array $options = array()) {
  return $index->query($options);
}

/**
 * Returns either a list of all available service infos, or a specific one.
 *
 * @see hook_search_api_service_info()
 *
 * @param $id
 *   The id of the service info to retrieve.
 *
 * @return
 *   If $id was not specified, an array of all available service classes.
 *   Otherwise, either the service info with the specified id (if it exists),
 *   or NULL.
 */
function search_api_get_service_info($id = NULL) {
  $services = &drupal_static(__FUNCTION__);

  if (!isset($services)) {
    $services = module_invoke_all('search_api_service_info');

    // Initialization of optional entries with default values
    foreach ($services as $key => $service) {
      if (!isset($service['init args'])) {
        $services[$key]['init args'] = array();
      }
    }

    // Allow other modules to alter definitions
    drupal_alter('search_api_service_info', $services);
  }

  if (isset($id)) {
    return isset($services[$id]) ? $services[$id] : NULL;
  }
  return $services;
}

/**
 * Returns a list of all available data alter callbacks.
 *
 * @see hook_search_api_alter_callback_info()
 *
 * @return
 *   An array of all available data alter callbacks, keyed by function name.
 */
function search_api_get_alter_callbacks() {
  $callbacks = &drupal_static(__FUNCTION__);

  if (!isset($callbacks)) {
    $callbacks = module_invoke_all('search_api_alter_callback_info');

    // Initialization of optional entries with default values
    foreach ($callbacks as $id => $callback) {
      $callbacks[$id] += array('enabled' => TRUE, 'weight' => 0);
    }

    // @todo drupal_alter('search_api_alter_callback_info', $callbacks)?
  }

  return $callbacks;
}

/**
 * Returns a list of all available pre- and post-processors.
 *
 * @see hook_search_api_processor_info()
 *
 * @return
 *   An array of all available processors, keyed by id.
 */
function search_api_get_processors() {
  $processors = &drupal_static(__FUNCTION__);

  if (!isset($processors)) {
    $processors = module_invoke_all('search_api_processor_info');

    // Initialization of optional entries with default values
    foreach ($processors as $id => $processor) {
      $processors[$id] += array('enabled pre' => TRUE, 'enabled post' => TRUE, 'weight' => 0);
    }

    // @todo drupal_alter('search_api_processor_info', $processors)?
  }

  return $processors;
}

/**
 * Returns a list of all (enabled) search servers.
 *
 * @param $only_enabled
 *   Whether to retrieve only enabled servers.
 * @param $header
 *   A table header to sort by.
 *
 * @return
 *   An array of objects representing all (or, if $enabled is TRUE, only
 *   enabled) search servers.
 */
function search_api_list_servers($only_enabled = TRUE, $header = NULL) {
  $servers = &drupal_static(__FUNCTION__);

  $enabled = (int) $only_enabled;
  if (!isset($servers[$enabled])) {
    $select = db_select('search_api_server', 's', array('fetch' => 'SearchApiServer'))->fields('s');
    if ($enabled) {
      $select->condition('s.enabled', 1);
    }
    if (!empty($header)) {
      $select = $select->extend('TableSort')->orderByHeader($header);
    }

    $results = $select->execute();
    $servers[$enabled] = array();
    foreach ($results as $row) {
      $row->options = unserialize($row->options);
      $servers[$enabled][$row->id] = $row;
    }

    module_invoke_all('search_api_server_load', $servers[$enabled]);
  }

  return $servers[$enabled];
}

/**
 * Load the search server with the specified id.
 *
 * @param $id
 *   The search server's id.
 *
 * @return
 *   The loaded and initialized SearchApiServer object
 *   representing the server with the specified id.
 */
function search_api_server_load($id) {
  $ret = entity_load('search_api_server', array($id));
  return $ret ? array_shift($ret) : FALSE;
}

/**
 * Implements hook_search_api_server_load().
 */
function search_api_search_api_server_load($servers) {
  $services = search_api_get_service_info();
  foreach ($servers as $server) {
    $server->init($services[$server->class]['init args']);
  }
}

/**
 * Entity uri callback.
 */
function search_api_server_url(SearchApiServer $server) {
  return array(
    'path' => 'admin/config/search/search_api/server/' . $server->id,
  );
}

/**
 * Inserts a new search server into the database.
 *
 * @param array $values
 *   An array containing the values to be inserted.
 *
 * @return
 *   The newly inserted server's id, or FALSE on error.
 */
function search_api_server_insert(array $values) {
  foreach (array('name', 'class', 'options') as $var) {
    if (empty($values[$var])) {
      throw new SearchApiException(t('Property !field has to be set for new server!', array('!field' => $var)));
    }
  }
  if (empty($values['description'])) {
    $values['description'] = NULL;
  }
  $fields = array(
    'name' => $values['name'],
    'description' => $values['description'],
    'enabled' => empty($values['enabled']) ? 0 : 1,
    'class' => $values['class'],
    'options' => serialize($values['options']),
  );
  if (!empty($values['id'])) {
    $fields['id'] = $values['id'];
  }

  $id = db_insert('search_api_server')->fields($fields)->execute();

  $server = search_api_server_load($id);
  $server->create();
  module_invoke_all('search_api_server_insert', $server);

  return $id;
}

/**
 * Changes a server's settings.
 *
 * @param SearchApiServer $server
 *   The server whose fields should be changed.
 * @param array $fields
 *   The new field values to set.
 *
 * @return
 *   1 if fields were changed, 0 if the fields already had the desired values.
 *   FALSE on failure.
 */
function search_api_server_edit(SearchApiServer $server, array $fields) {
  $server_values = (array) $server;
  foreach ($fields as $field => $value) {
    if (!array_key_exists($field, $server_values) || $value === $server->$field) {
      unset($fields[$field]);
    }
  }
  // If there are no new values, just return 0.
  if (empty($fields)) {
    return 0;
  }

  // Notify server of changed values.
  $server->update($fields);

  if (isset($fields['options'])) {
    $fields['options'] = serialize($fields['options']);
  }
  $ret = db_update('search_api_server')
    ->fields($fields)
    ->condition('id', $server->id)
    ->execute();

  if (!$ret) {
    return $ret;
  }

  $server = search_api_server_load($server->id);

  module_invoke_all('search_api_server_update', $server, 'edit');

  return $ret;
}

/**
 * Enables a search server. Will also check for remembered tasks for this server
 * and execute them.
 *
 * @param SearchApiServer $server
 *   The server to enable.
 *
 * @return
 *   1 on success, 0 or FALSE on failure.
 */
function search_api_server_enable(SearchApiServer $server) {
  if ($server->enabled) {
    return 0;
  }

  $server->enable();

  $ret = db_update('search_api_server')
    ->fields(array('enabled' => 1))
    ->condition('id', $server->id)
    ->execute();
  if (!$ret) {
    return $ret;
  }

  $server->enabled = 1;
  module_invoke_all('search_api_server_update', $server, 'enable');

  // Were there any changes in the server's indexes while it was disabled?
  $tasks = variable_get('search_api_tasks', array());
  if (isset($tasks[$server->id])) {
    foreach ($tasks[$server->id] as $index_id => $index_tasks) {
      $index = search_api_index_load($index_id);
      foreach ($index_tasks as $task) {
        switch ($task) {
          case 'add':
            $server->addIndex($index);
            break;
          case 'clear':
            $server->deleteItems('all', $index);
            break;
          case 'fields':
            if ($server->fieldsUpdated($index)) {
              _search_api_index_reindex($index);
            }
            break;
          case 'remove':
            $server->removeIndex($index ? $index : $index_id);
            break;
          default:
            if (substr($task, 0, 7) == 'delete-') {
              $id = substr($task, 7);
              $server->deleteItems(array($id), $index);
            }
            else {
              watchdog('search_api', t('Unknown task "!task" for server "!name".', array('!task' => $task, '!server' => $server->name)), NULL, 'warning');
            }
        }
      }
    }
    unset($tasks[$server->id]);
    variable_set('search_api_tasks', $tasks);
  }

  return $ret;
}

/**
 * Disables a search server, along with all associated indexes.
 *
 * @param SearchApiServer $server
 *   The server to disable.
 *
 * @return
 *   1 on success, 0 or FALSE on failure.
 */
function search_api_server_disable(SearchApiServer $server) {
  if (!$server->enabled) {
    return 0;
  }

  $server->disable();

  $id = $server->id;
  $result = db_select('search_api_index', 'i')
    ->fields('i')
    ->condition('server', $id)
    ->condition('enabled', 1)
    ->execute();
  foreach ($result as $index) {
    search_api_index_disable($index);
  }
  $ret = db_update('search_api_server')
    ->fields(array('enabled' => 0))
    ->condition('id', $id)
    ->execute();
  if (!$ret) {
    return $ret;
  }

  $server->enabled = 0;
  module_invoke_all('search_api_server_update', $server, 'disable');

  return $ret;
}

/**
 * Deletes a search server and disables all associated indexes.
 *
 * @param SearchApiServer $server
 *   The server to delete.
 *
 * @return
 *   1 on success, 0 or FALSE on failure.
 */
function search_api_server_delete(SearchApiServer $server) {
  // Call hook method before doing anything.
  $server->delete();

  $id = $server->id;
  $result = db_select('search_api_index', 'i')
    ->fields('i')
    ->condition('server', $id)
    ->condition('enabled', 1)
    ->execute();
  foreach ($result as $index) {
    search_api_index_disable($index);
  }
  db_update('search_api_index')
    ->fields(array('server' => NULL))
    ->condition('server', $id)
    ->execute();
  $ret = db_delete('search_api_server')
    ->condition('id', $id)
    ->execute();
  if (!$ret) {
    return $ret;
  }

  $tasks = variable_get('search_api_tasks', array());
  unset($tasks[$server->id]);
  variable_set('search_api_tasks', $tasks);

  module_invoke_all('search_api_server_delete', $server);

  return $ret;
}

/**
 * Returns a list of search indexes.
 *
 * @param $options
 *   An associative array of conditions on the returned indexes.
 *   - only_enabled: Unless set to FALSE, only enabled indexes will be returned.
 *   - server: Return only indexes on the server with the specified id.
 *   - entity_type: Return only indexes on the specified entity type.
 * @param $header
 *   A table header to sort by.
 *
 * @return
 *   An array of objects representing the search indexes that meet the
 *   specified criteria.
 */
function search_api_list_indexes(array $options = array(), $header = NULL) {
  $enabled = isset($options['only_enabled']) && !$options['only_enabled'] ? 0 : 1;
  $server = empty($options['server']) ? NULL : $options['server'];
  $type = empty($options['entity_type']) ? NULL : $options['entity_type'];

  $select = db_select('search_api_index', 'i', array('fetch' => 'SearchApiServer'))->fields('i');
  if ($enabled) {
    $select->condition('i.enabled', 1);
  }
  if (!empty($server)) {
    $select->condition('i.server', $server);
  }
  if (!empty($type)) {
    $select->condition('i.entity_type', $type);
  }
  if (!empty($header)) {
    $select = $select->extend('TableSort')->orderByHeader($header);
  }

  $results = $select->execute();
  $indexes = array();
  foreach ($results as $row) {
    $row->options = unserialize($row->options);
    $indexes[$row->id] = $row;
  }

  module_invoke_all('search_api_index_load', $indexes);

  return $indexes;
}

/**
 * Loads the Search API index with the specified id.
 *
 * @param $id
 *   The index' id.
 *
 * @return
 *   A completely loaded index object, or FALSE if no such index exists.
 */
function search_api_index_load($id) {
  $ret = entity_load('search_api_index', array($id));
  return $ret ? array_shift($ret) : FALSE;
}

/**
 * Determines a search index' indexing status.
 *
 * @param $index
 *   Either an index object, or the index' id.
 *
 * @return
 *   An associative array containing two keys (in this order):
 *   - indexed: The number of items already indexed in their latest version.
 *   - total: The total number of items that have to be indexed for this index.
 */
function search_api_index_status($index) {
  $id = is_object($index) ? $index->id : $index;
  $indexed = db_select('search_api_item', 'i')
    ->condition('index_id', $id)
    ->condition('changed', 0)
    ->countQuery()
    ->execute()
    ->fetchField();
  $total = db_select('search_api_item', 'i')
    ->condition('index_id', $id)
    ->countQuery()
    ->execute()
    ->fetchField();
  return array('indexed' => $indexed, 'total' => $total);
}

/**
 * Entity uri callback.
 */
function search_api_index_url(SearchApiIndex $index) {
  return array(
    'path' => 'admin/config/search/search_api/index/' . $index->id,
  );
}

/**
 * Inserts a new search index into the database.
 *
 * @param array $values
 *   An array containing the values to be inserted.
 *
 * @return
 *   The newly inserted index' id, or FALSE on error.
 */
function search_api_index_insert(array $values) {
  foreach (array('name', 'entity_type', 'options') as $var) {
    if (empty($values[$var])) {
      throw new SearchApiException(t('Field !field has to be set for new index!', array('!field' => $var)));
      return FALSE;
    }
  }
  if (empty($values['description'])) {
    $values['description'] = NULL;
  }
  if ($values['server'] === '') {
    $values['server'] = NULL;
  }

  if (isset($values['server'])) {
    $server = search_api_server_load($values['server']);
    if (!$server) {
      throw new SearchApiException(t('Unknown server specified for new index (id !id)!', array('!id' => $values['server'])));
    }
    if (!$server->enabled) {
      // Indexes on a disabled server cannot be enabled.
      $values['enabled'] = 0;
    }
    else {
      $values['enabled'] = (isset($values['enabled']) && !$values['enabled']) ? 0 : 1;
    }
  }
  else {
    // Indexes with no server cannot be enabled.
    $values['enabled'] = 0;
  }

  $fields = array(
    'name' => $values['name'],
    'description' => $values['description'],
    'enabled' => $values['enabled'],
    'server' => $values['server'],
    'entity_type' => $values['entity_type'],
    'options' => serialize($values['options']),
  );
  if (!empty($values['id'])) {
    $fields['id'] = $values['id'];
  }

  $id = db_insert('search_api_index')->fields($fields)->execute();

  // Remember items to index
  $entity_info = entity_get_info($values['entity_type']);
  if (!empty($entity_info['base table'])) {
    // Use a subselect, which will probably be much faster than entity_load().
    // @todo Can we assume this always works when 'base table' is set?
    $id_field = $entity_info['entity keys']['id'];
    $table = $entity_info['base table'];
    $query = db_select($table, 't');
    $query->addField('t', $id_field, 'item_id');
    $query->addExpression(':index_id', 'index_id', array(':index_id' => $id));
    $query->addExpression('1', 'changed');

    db_insert('search_api_item')->from($query)->execute();
  }
  else {
    // We have to use the slow entity_load().
    $entities = entity_load($values['entity_type'], FALSE);
    $query = db_insert('search_api_item')->fields('item_id', 'index_id', 'changed');
    foreach ($entities as $item_id => $entity) {
      $query->values(array(
        'item_id' => $item_id,
        'index_id' => $id,
        'changed' => 1,
      ));
    }
    $query->execute();
  }

  // Call hooks
  $values['id'] = $id;
  $index = new SearchApiIndex($values);
  if ($index->server) {
    if ($server->enabled) {
      $server->addIndex($index);
    }
    else {
      $tasks = variable_get('search_api_tasks', array());
      // When we add or remove an index, we can ignore all other tasks.
      $tasks[$server->id][$id] = array('add');
      variable_set('search_api_tasks', $tasks);
    }
  }
  module_invoke_all('search_api_index_insert', $index);

  return $id;
}

/**
 * Changes an index' settings.
 *
 * @param SearchApiIndex $index
 *   The server whose fields should be changed.
 * @param array $fields
 *   The new field values to set.
 *
 * @return
 *   1 if fields were changed, 0 if the fields already had the desired values.
 *   FALSE on failure.
 */
function search_api_index_edit(SearchApiIndex $index, array $fields) {
  if (isset($fields['server']) && $fields['server'] === '') {
    $fields['server'] = NULL;
  }
  $index_values = (array) $index;
  foreach ($fields as $field => $value) {
    if (!array_key_exists($field, $index_values) || $value === $index->$field) {
      unset($fields[$field]);
    }
  }
  // If there are no new values, just return 0.
  if (empty($fields)) {
    return 0;
  }

  if (isset($fields['options'])) {
    $fields['options'] = serialize($fields['options']);
  }

  $ret = db_update('search_api_index')
    ->fields($fields)
    ->condition('id', $index->id)
    ->execute();

  if (!$ret) {
    return $ret;
  }

  $new_index = search_api_index_load($index->id);

  if ($index->server != $new_index->server) {
    // Server changed - inform old and new ones.
    if ($index->server) {
      $old_server = search_api_server_load($index->server);
      if ($old_server->enabled) {
        $old_server->removeIndex($new_index);
      }
      else {
        $tasks = variable_get('search_api_tasks', array());
        // When we add or remove an index, we can ignore all other tasks.
        $tasks[$old_server->id][$index->id] = array('remove');
        variable_set('search_api_tasks', $tasks);
      }
    }

    if ($new_index->server) {
      $new_server = search_api_server_load($new_index->server);
      if ($new_server->enabled) {
        $new_server->addIndex($new_index);
      }
      else {
        $tasks = variable_get('search_api_tasks', array());
        // When we add or remove an index, we can ignore all other tasks.
        $tasks[$new_server->id][$index->id] = array('add');
        variable_set('search_api_tasks', $tasks);
      }
    }

    // We also have to re-index all content
    search_api_index_reindex($index);
  }

  module_invoke_all('search_api_index_update', $new_index, 'edit');

  return $ret;
}

/**
 * Changes an index' indexed field settings.
 *
 * @param SearchApiIndex $index
 *   The server whose fields should be changed.
 * @param array $fields
 *   The new indexed field settings.
 *
 * @return
 *   1 if the field settings were changed, 0 if they already had the desired
 *   values.
 */
function search_api_index_edit_fields(SearchApiIndex $index, array $fields) {
  // If there are no new values, just return 0.
  $options = $index->options + array('fields' => array());
  if ($fields == $options['fields']) {
    return 0;
  }
  $options['fields'] = $fields;

  $ret = db_update('search_api_index')
    ->fields(array('options' => serialize($options)))
    ->condition('id', $index->id)
    ->execute();

  if (!$ret) {
    return $ret;
  }

  $index = search_api_index_load($index->id);

  if ($index->server) {
    $server = search_api_server_load($index->server);
    if ($server->enabled) {
      if ($server->fieldsUpdated($index)) {
        _search_api_index_reindex($index);
      }
    }
    else {
      $tasks = variable_get('search_api_tasks', array());
      if (!isset($tasks[$server->id][$index->id])
              // We don't need to notify the server twice of field changes.
          || (array_search('fields', $tasks[$server->id][$index->id]) === FALSE
              // Adding a server also re-examines the field settings.
              && array_search('add', $tasks[$server->id][$index->id]) === FALSE)) {
        $tasks[$server->id][$index->id][] = 'fields';
        variable_set('search_api_tasks', $tasks);
      }
    }
  }

  module_invoke_all('search_api_index_update', $index, 'fields');

  return $ret;
}

/**
 * Enables a search index.
 *
 * @param SearchApiIndex $index
 *   The index to enable.
 *
 * @return
 *   1 on success, 0 or FALSE on failure.
 */
function search_api_index_enable(SearchApiIndex $index) {
  $ret = db_update('search_api_index')
    ->fields(array('enabled' => 1))
    ->condition('id', $index->id)
    ->execute();
  if (!$ret) {
    return $ret;
  }

  $index->enabled = 1;
  module_invoke_all('search_api_index_update', $index, 'enable');

  return $ret;
}

/**
 * Disables a search index.
 *
 * @param SearchApiIndex $index
 *   The index to disable.
 *
 * @return
 *   1 on success, 0 or FALSE on failure.
 */
function search_api_index_disable(SearchApiIndex $index) {
  $ret = db_update('search_api_index')
    ->fields(array('enabled' => 0))
    ->condition('id', $index->id)
    ->execute();
  if (!$ret) {
    return $ret;
  }

  $index->enabled = 0;
  module_invoke_all('search_api_index_update', $index, 'disable');

  return $ret;
}

/**
 * Schedules a search index for re-indexing.
 *
 * @param SearchApiIndex $index
 *   The index to re-index.
 *
 * @return
 *   TRUE on success, FALSE on failure.
 */
function search_api_index_reindex(SearchApiIndex $index) {
  $ret = _search_api_index_reindex($index);

  if(!$ret) {
    // If there just were no unchanged items, we don't want to report failure
    return TRUE;
  }

  module_invoke_all('search_api_index_update', $index, 'reindex');

  return TRUE;
}

/**
 * Helper method for marking all items on an index as needing re-indexing.
 *
 * @param SearchApiIndex $index
 *   The index to re-index.
 *
 * @return
 *   The number of items affected.
 */
function _search_api_index_reindex(SearchApiIndex $index) {
  return db_update('search_api_item')
    ->fields(array('changed' => REQUEST_TIME))
    ->condition('changed', 0)
    ->condition('index_id', $index->id)
    ->execute();
}

/**
 * Clears a search index and schedules all of its items for re-indexing.
 *
 * @param SearchApiIndex $index
 *   The index to clear.
 *
 * @return
 *   TRUE on success, FALSE on failure.
 */
function search_api_index_clear(SearchApiIndex $index) {
  if ($index->server) {
    $server = search_api_server_load($index->server);
    if ($server->enabled) {
      $server->deleteItems('all', $index);
    }
    else {
      $tasks = variable_get('search_api_tasks', array());
      // If the index was cleared or newly added since the server was last enabled, we don't need to do anything.
      if (!isset($tasks[$server->id][$index->id])
          || (array_search('add', $tasks[$server->id][$index->id]) === FALSE
              && array_search('clear', $tasks[$server->id][$index->id]) === FALSE)) {
        $tasks[$server->id][$index->id][] = 'clear';
        variable_set('search_api_tasks', $tasks);
      }
    }
  }

  $ret = _search_api_index_reindex($index);

  if(!$ret) {
    // If there just were no unchanged items, we don't want to report failure.
    return TRUE;
  }

  module_invoke_all('search_api_index_update', $index, 'clear');

  return TRUE;
}

/**
 * Deletes a search index.
 *
 * @param SearchApiIndex $index
 *   The index to delete.
 *
 * @return
 *   TRUE on success, FALSE on failure.
 */
function search_api_index_delete(SearchApiIndex $index) {
  if ($index->server) {
    $server = search_api_server_load($index->server);
    if ($server->enabled) {
      $server->removeIndex($index);
    }
    else {
      $tasks = variable_get('search_api_tasks', array());
      $tasks[$server->id][$index->id] = array('remove');
      variable_set('search_api_tasks', $tasks);
    }
  }

  $ret = db_delete('search_api_index')
    ->condition('id', $index->id)
    ->execute();

  if (!$ret) {
    return FALSE;
  }

  db_delete('search_api_item')
    ->condition('index_id', $index->id)
    ->execute();

  module_invoke_all('search_api_index_delete', $index);

  return TRUE;
}
