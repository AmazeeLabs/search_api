<?php
/**
 * @file
 * Contains the Search API hook implementations.
 */

use Drupal\Core\Entity\ContentEntityType;
use Drupal\Core\Entity\EntityInterface;

/*
 * Constant definitions.
 */

/**
 * Default number of items indexed per cron batch for each enabled index.
 */
define('SEARCH_API_DEFAULT_CRON_LIMIT', 50);

/*
 * Hook implementations.
 */

/**
 * Implements hook_menu_link_defaults().
 */
function search_api_menu_link_defaults() {
  return array(
    'search_api.overview' => array(
      'link_title' => 'Search API',
      'description' => 'Create and configure search engines.',
      'route_name' => 'search_api.overview',
      'parent' => 'system.admin_config_search',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function search_api_permission() {
  return array(
    'administer search_api' => array(
      'title' => t('Administer Search API'),
      'description' => t('Create and configure Search API servers and indexes.'),
    ),
  );
}

/**
 * Implements hook_entity_insert().
 */
function search_api_entity_insert(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity insert.
  }
}

/**
 * Implements hook_entity_update().
 */
function search_api_entity_update(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity change.
  }
}

/**
 * Implements hook_entity_delete().
 */
function search_api_entity_delete(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity delete.
  }
}

/**
 * Determines whether a field of the given type contains text data.
 *
 * @param string $type
 *   A string containing the type to check.
 * @param array $allowed
 *   Optionally, an array of allowed types.
 *
 * @return bool
 *   TRUE if $type is either one of the specified types, or a list of such
 *   values. FALSE otherwise.
 */
function search_api_is_text_type($type, array $allowed = array('text')) {
  return in_array(search_api_extract_inner_type($type), $allowed);
}

/**
 * Determines whether a field of the given type contains a list of any kind.
 *
 * @param string $type
 *   A string containing the type to check.
 *
 * @return bool
 *   TRUE iff $type is a list type ("list<*>").
 */
function search_api_is_list_type($type) {
  return substr($type, 0, 5) == 'list<';
}

/**
 * Determines the nesting level of a list type.
 *
 * @param string $type
 *   The type to check.
 *
 * @return int
 *   The nesting level of the type. 0 for singular types, 1 for lists of
 *   singular types, etc.
 */
function search_api_list_nesting_level($type) {
  $level = 0;
  while (search_api_is_list_type($type)) {
    $type = substr($type, 5, -1);
    ++$level;
  }
  return $level;
}

/**
 * Nests a type to the same level as another type.
 *
 * I.e., after
 * @code
 * $t = search_api_nest_type($type, $nested_type);
 * @endcode
 * is executed, the following statements will always be true:
 *
 * @code
 * search_api_list_nesting_level($t) == search_api_list_nesting_level($nested_type);
 * search_api_extract_inner_type($t) == search_api_extract_inner_type($type);
 * @endcode
 *
 * @param string $type
 *   The type to wrap.
 * @param string $nested_type
 *   Another type, determining the nesting level.
 *
 * @return string
 *   A list version of $type, as specified above.
 */
function search_api_nest_type($type, $nested_type) {
  while (search_api_is_list_type($nested_type)) {
    $nested_type = substr($nested_type, 5, -1);
    $type = "list<$type>";
  }
  return $type;
}

/**
 * Extracts the contained primitive type of a list type.
 *
 * @param string $type
 *   A string containing the list type to process.
 *
 * @return string
 *   A string containing the primitive type contained within the list, e.g.
 *   "text" for "list<text>" (or for "list<list<text>>"). If $type is no list
 *   type, it is returned unchanged.
 */
function search_api_extract_inner_type($type) {
  while (search_api_is_list_type($type)) {
    $type = substr($type, 5, -1);
  }
  return $type;
}

/**
 * Checks whether it is possible to sort on fields of the given type.
 *
 * @param $type
 *   The type to check for.
 *
 * @return bool
 *   TRUE if this type is sortable, FALSE otherwise.
 */
function search_api_is_sortable_type($type) {
  return !search_api_is_text_type($type) && !search_api_is_list_type($type);
}

/**
 * Returns all field types recognized by the Search API framework.
 *
 * @return array
 *   An associative array with all recognized types as keys, mapped to their
 *   translated display names.
 *
 * @see search_api_default_field_types()
 * @see search_api_get_data_type_info()
 */
function search_api_field_types() {
  $types = search_api_default_field_types();
  foreach (search_api_get_data_type_info() as $id => $type) {
    $types[$id] = $type['name'];
  }
  return $types;
}

/**
 * Returns the default field types recognized by the Search API framework.
 *
 * @return array
 *   An associative array with the default types as keys, mapped to their
 *   translated display names.
 */
function search_api_default_field_types() {
  return array(
    'text' => t('Fulltext'),
    'string' => t('String'),
    'integer' => t('Integer'),
    'decimal' => t('Decimal'),
    'date' => t('Date'),
    'duration' => t('Duration'),
    'boolean' => t('Boolean'),
    'uri' => t('URI'),
  );
}

/**
 * Returns either all custom field type definitions, or a specific one.
 *
 * @param $type
 *   If specified, the type whose definition should be returned.
 *
 * @return array
 *   If $type was not given, an array containing all custom data types, in the
 *   format specified by hook_search_api_data_type_info().
 *   Otherwise, the definition for the given type, or NULL if it is unknown.
 *
 * @see hook_search_api_data_type_info()
 */
function search_api_get_data_type_info($type = NULL) {
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    $default_types = search_api_default_field_types();
    $types =  \Drupal::moduleHandler()->invokeAll('search_api_data_type_info');
    $types = $types ? $types : array();
    foreach ($types as &$type_info) {
      if (!isset($type_info['fallback']) || !isset($default_types[$type_info['fallback']])) {
        $type_info['fallback'] = 'string';
      }
    }
    \Drupal::moduleHandler()->alter('search_api_data_type_info', $types);
  }
  if (isset($type)) {
    return isset($types[$type]) ? $types[$type] : NULL;
  }
  return $types;
}

/**
 * Extracts specific field values from an EntityMetadataWrapper object.
 *
 * @see Drupal\search_api\Plugin\SearchApi\Processor\Highlight::getFulltextfields()
 * @todo
 */
function search_api_extract_fields($wrapper, array $fields, array $value_options = array()) {
  return array();
}
