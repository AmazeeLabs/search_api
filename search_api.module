<?php
/**
 * @file
 * Contains the Search API hook implementations.
 */

use Drupal\Core\Entity\ContentEntityType;
use Drupal\Core\Entity\EntityInterface;

/*
 * Constant definitions.
 */

/**
 * Default number of items indexed per cron batch for each enabled index.
 */
define('SEARCH_API_DEFAULT_CRON_LIMIT', 50);

/*
 * Hook implementations.
 */

/**
 * Implements hook_menu_link_defaults().
 */
function search_api_menu_link_defaults() {
  return array(
    'search_api.overview' => array(
      'link_title' => 'Search API',
      'description' => 'Create and configure search engines.',
      'route_name' => 'search_api.overview',
      'parent' => 'system.admin_config_search',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function search_api_permission() {
  return array(
    'administer search_api' => array(
      'title' => t('Administer Search API'),
      'description' => t('Create and configure Search API servers and indexes.'),
    ),
  );
}

/**
 * Implements hook_entity_insert().
 */
function search_api_entity_insert(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity insert.
  }
}

/**
 * Implements hook_entity_update().
 */
function search_api_entity_update(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity change.
  }
}

/**
 * Implements hook_entity_delete().
 */
function search_api_entity_delete(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityType) {
    // @todo: Track entity delete.
  }
}

/**
 * Implements hook_entity_operation_alter().
 *
 * @todo rewrite it regarding to https://drupal.org/node/1839516
 * @todo Should it be moved to SearchApiController->buildRow() ?
 */
function search_api_entity_operation_alter(array &$operations, \Drupal\Core\Entity\EntityInterface $entity) {
  if (($entity->getEntityTypeId() == 'search_api_index' || $entity->getEntityTypeId() == 'search_api_server')
    && !$entity->status() && !empty($operations['enable'])) {
    if ($entity->getEntityTypeId() == 'search_api_index') {
      $operations['enable']['route_name'] = 'search_api.index_bypass_enable';
    }
    else {
      $operations['enable']['route_name'] = 'search_api.server_bypass_enable';
    }

    $operations['enable']['route_parameters']['token'] = \Drupal::csrfToken()->get($entity->id());
  }
}

/**
 * Determines whether a field of the given type contains text data.
 *
 * @param string $type
 *   A string containing the type to check.
 * @param array $allowed
 *   Optionally, an array of allowed types.
 *
 * @return bool
 *   TRUE if $type is either one of the specified types, or a list of such
 *   values. FALSE otherwise.
 */
function search_api_is_text_type($type, array $allowed = array('text')) {
  return in_array($type, $allowed);
}

/**
 * Checks whether it is possible to sort on fields of the given type.
 *
 * @param $type
 *   The type to check for.
 *
 * @todo
 *   Make sure you take the field object and check the isMultiple parameter
 *
 * @return bool
 *   TRUE if this type is sortable, FALSE otherwise.
 */
function search_api_is_sortable_type($type) {
  return !search_api_is_text_type($type);
}

/**
 * Returns all field types recognized by the Search API framework.
 *
 * @return array
 *   An associative array with all recognized types as keys, mapped to their
 *   translated display names.
 *
 * @see search_api_default_index_types()
 * @see search_api_get_data_type_info()
 */
function search_api_data_types() {
  $types = search_api_default_data_types();
  foreach (search_api_get_data_type_info() as $id => $type) {
    $types[$id] = $type['name'];
  }

  return $types;
}

/**
 * Get the mapping between data types and field types
 *
 * @return array
 *   $mapping array with the field type that is requested and it's default data type for a sensible default
 */
function search_api_field_type_mapping() {

  /** @var \Drupal\Core\Field\FieldTypePluginManager $field_type_service */
  $field_type_service = \Drupal::service('plugin.manager.field.field_type');
  $field_types = $field_type_service->getDefinitions();

  $mapping = array();
  foreach ($field_types as $field_type_id => $field_type) {
    /** @var $field_type \Drupal\Core\Field\FieldDefinition */
    switch ($field_type_id) {
      case 'comment':
      case 'list_text':
      case 'text':
      case 'text_long':
      case 'text_with_summary':
        $mapping[$field_type_id] = 'text';
        break;
      case 'path':
      case 'uri':
      case 'email':
      case 'language':
      case 'string':
      case 'string_long':
      case 'uuid':
        $mapping[$field_type_id] = 'string';
        break;
      case 'datetime':
      case 'date':
      case 'changed':
      case 'created':
      case 'timestamp':
        $mapping[$field_type_id] = 'date';
        break;
      case 'list_boolean':
      case 'boolean':
        $mapping[$field_type_id] = 'boolean';
        break;
      case 'list_float':
      case 'float':
        $mapping[$field_type_id] = 'float';
        break;
      case 'list_integer':
      case 'integer':
        $mapping[$field_type_id] = 'integer';
        break;
      case 'decimal':
        $mapping[$field_type_id] = 'decimal';
        break;
      case 'token':
        $mapping[$field_type_id] = 'string';
        break;
    }
  }
  // Allow other modules to intercept and define what default type they want to use for their field type.
  \Drupal::moduleHandler()->alter('search_api_field_type_mapping', $mapping);
  return $mapping;
}

/**
 * Returns the default field types recognized by the Search API framework.
 *
 * @return array
 *   An associative array with the default types as keys, mapped to their
 *   translated display names.
 */
function search_api_default_data_types() {
  return array(
    'text' => t('Fulltext'),
    'string' => t('String'),
    'integer' => t('Integer'),
    'decimal' => t('Decimal'),
    'date' => t('Date'),
    'boolean' => t('Boolean'),
  );
}

/**
 * Returns either all custom field type definitions, or a specific one.
 *
 * @param $type
 *   If specified, the type whose definition should be returned.
 *
 * @return array
 *   If $type was not given, an array containing all custom data types, in the
 *   format specified by hook_search_api_data_type_info().
 *   Otherwise, the definition for the given type, or NULL if it is unknown.
 *
 * @see hook_search_api_data_type_info()
 */
function search_api_get_data_type_info($type = NULL) {
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    $default_types = search_api_default_data_types();
    $types =  \Drupal::moduleHandler()->invokeAll('search_api_data_type_info');
    $types = $types ? $types : array();
    foreach ($types as &$type_info) {
      if (!isset($type_info['fallback']) || !isset($default_types[$type_info['fallback']])) {
        $type_info['fallback'] = 'string';
      }
    }
    \Drupal::moduleHandler()->alter('search_api_data_type_info', $types);
  }
  if (isset($type)) {
    return isset($types[$type]) ? $types[$type] : NULL;
  }
  return $types;
}

/**
 * Extracts specific field values from an EntityMetadataWrapper object.
 *
 * @see Drupal\search_api\Plugin\SearchApi\Processor\Highlight::getFulltextfields()
 * @todo
 */
function search_api_extract_fields($wrapper, array $fields, array $value_options = array()) {
  return array();
}

/**
 * Implements hook_theme().
 */
function search_api_theme() {
  $themes['search_api_admin_fields_table'] = array(
    'render element' => 'element',
  );

  return $themes;
}

/**
 * Returns HTML for a field list form.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the form.
 */
function theme_search_api_admin_fields_table($variables) {
  $form = $variables['element'];
  $header = array(t('Field'), t('Machine name'), t('Indexed'), t('Type'), t('Boost'));

  $rows = array();
  if (!empty($form['fields'])) {
    foreach (\Drupal\Core\Render\Element::children($form['fields']) as $name) {
      $row = array();
      foreach (\Drupal\Core\Render\Element::children($form['fields'][$name]) as $field) {
        if ($cell = render($form['fields'][$name][$field])) {
          $row[] = $cell;
        }
      }
      if (empty($form['fields'][$name]['description']['#value'])) {
        $rows[] = _search_api_deep_copy($row);
      }
      else {
        $rows[] = array(
          'data' => $row,
          'title' => strip_tags($form['fields'][$name]['description']['#value']),
        );
      }
    }
  }

  $note = isset($form['note']) ? $form['note'] : '';
  $submit = $form['submit'];
  $additional = isset($form['additional']) ? $form['additional'] : FALSE;
  unset($form['note'], $form['submit'], $form['additional']);
  $output = drupal_render_children($form);

  $build = array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
  );

  $output .= drupal_render($build);
  $output .= render($note);
  $output .= render($submit);
  if ($additional) {
    $output .= render($additional);
  }

  return $output;
}

/**
 * Returns a deep copy of the input array.
 *
 * The behavior of PHP regarding arrays with references pointing to it is rather
 * weird. Therefore, we use this helper function in theme_search_api_index() to
 * create safe copies of such arrays.
 *
 * @param array $array
 *   The array to copy.
 *
 * @return array
 *   A deep copy of the array.
 */
function _search_api_deep_copy(array $array) {
  $copy = array();
  foreach ($array as $k => $v) {
    if (is_array($v)) {
      $copy[$k] = _search_api_deep_copy($v);
    }
    elseif (is_object($v)) {
      $copy[$k] = clone $v;
    }
    elseif ($v) {
      $copy[$k] = $v;
    }
  }
  return $copy;
}
