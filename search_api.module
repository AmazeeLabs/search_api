<?php
/**
 * @file
 * Contains the Search API hook implementations.
 */

use Drupal\Component\Utility\String;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\TypedData\ComplexDataDefinitionInterface;
use Drupal\Core\TypedData\ComplexDataInterface;
use Drupal\Core\TypedData\TypedDataInterface;
use Drupal\search_api\Server\ServerInterface;
use Drupal\search_api\Utility\Utility;

/*
 * Constant definitions.
 */

/**
 * Default number of items indexed per cron batch for each enabled index.
 */
define('SEARCH_API_DEFAULT_CRON_LIMIT', 50);

/*
 * Hook implementations.
 */

/**
 * Implements hook_menu_link_defaults().
 */
function search_api_menu_link_defaults() {
  return array(
    'search_api.overview' => array(
      'link_title' => 'Search API',
      'description' => 'Create and configure search engines.',
      'route_name' => 'search_api.overview',
      'parent' => 'system.admin_config_search',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function search_api_permission() {
  return array(
    'administer search_api' => array(
      'title' => t('Administer Search API'),
      'description' => t('Create and configure Search API servers and indexes.'),
    ),
  );
}

/**
 * Implements hook_entity_insert().
 *
 * Adds an entry to the tracking table for each index that tracks this entity.
 *
 * @param EntityInterface $entity
 */
function search_api_entity_insert(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityInterface) {

    $storage = \Drupal::entityManager()->getStorage('search_api_index');
    $indexes = $storage->getIndexesForEntity($entity);

    foreach ($indexes as $index) {
      /** @var \Drupal\search_api\Entity\Index $index */
      if ($index->isServerEnabled()) {
        $index->getDatasource()->getTracker()->trackInsert(array($entity->id()));
      }
    }
  }
}

/**
 * Implements hook_entity_update().
 *
 * Updates the entry to the tracking table for each index that tracks this entity.
 *
 * @param EntityInterface $entity
 */
function search_api_entity_update(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityInterface) {

    // Get the IndexStorage class so we can find out which indexes support the entity that needs to be tracked
    $storage = \Drupal::entityManager()->getStorage('search_api_index');
    //
    $indexes = $storage->getIndexesForEntity($entity);

    foreach ($indexes as $index) {
      /** @var \Drupal\search_api\Entity\Index $index */
      if ($index->isServerEnabled()) {
        $index->getDatasource()->getTracker()->trackUpdate(array($entity->id()));
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Deletes the entry from the tracking table for each index that tracks this entity.
 *
 * @param EntityInterface $entity
 */
function search_api_entity_delete(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityInterface) {

    $storage = \Drupal::entityManager()->getStorage('search_api_index');
    $indexes = $storage->getIndexesForEntity($entity);

    foreach ($indexes as $index) {
      /** @var \Drupal\search_api\Entity\Index $index */
      if ($index->isServerEnabled()) {
        $index->getDatasource()->getTracker()->trackDelete(array($entity->id()));
      }
    }
  }
}

/**
 * Implements hook_entity_operation_alter().
 *
 * @todo rewrite it regarding to https://drupal.org/node/1839516
 * @todo Should it be moved to SearchApiController->buildRow() ?
 */
function search_api_entity_operation_alter(array &$operations, \Drupal\Core\Entity\EntityInterface $entity) {
  if (($entity->getEntityTypeId() == 'search_api_index' || $entity->getEntityTypeId() == 'search_api_server')
    && !$entity->status() && !empty($operations['enable'])) {
    if ($entity->getEntityTypeId() == 'search_api_index') {
      $operations['enable']['route_name'] = 'search_api.index_bypass_enable';
    }
    else {
      $operations['enable']['route_name'] = 'search_api.server_bypass_enable';
    }

    $operations['enable']['route_parameters']['token'] = \Drupal::csrfToken()->get($entity->id());
  }
}

/**
 * Determines whether a field of the given type contains text data.
 *
 * @depreciated
 *
 * @param string $type
 *   A string containing the type to check.
 * @param array $allowed
 *   Optionally, an array of allowed types.
 *
 * @return bool
 *   TRUE if $type is either one of the specified types, or a list of such
 *   values. FALSE otherwise.
 */
function search_api_is_text_type($type, array $allowed = array('text')) {
  return Utility::isTextType($type, $allowed);
}

/**
 * Checks whether it is possible to sort on fields of the given type.
 *
 * @depreciated
 *
 * @param $type
 *   The type to check for.
 *
 * @todo
 *   Make sure you take the field object and check the isMultiple parameter
 *
 * @return bool
 *   TRUE if this type is sortable, FALSE otherwise.
 */
function search_api_is_sortable_type($type) {
  return Utility::isSortableType($type);
}

/**
 * Returns all field types recognized by the Search API framework.
 *
 * @depreciated
 *
 * @return array
 *   An associative array with all recognized types as keys, mapped to their
 *   translated display names.
 *
 * @see search_api_default_index_types()
 * @see search_api_get_data_type_info()
 */
function search_api_data_types() {
  return Utility::getDataTypes();
}

/**
 * Get the mapping between data types and field types
 *
 * @depreciated
 *
 * @return array
 *   $mapping array with the field type that is requested and it's default data type for a sensible default
 */
function search_api_field_type_mapping() {
  return Utility::getFieldTypeMapping();
}

/**
 * Returns the default field types recognized by the Search API framework.
 *
 * @depreciated
 *
 * @return array
 *   An associative array with the default types as keys, mapped to their
 *   translated display names.
 */
function search_api_default_data_types() {
  return Utility::getDefaultDataTypes();
}

/**
 * Returns either all custom field type definitions, or a specific one.
 *
 * @depreciated
 *
 * @param $type
 *   If specified, the type whose definition should be returned.
 *
 * @return array
 *   If $type was not given, an array containing all custom data types, in the
 *   format specified by hook_search_api_data_type_info().
 *   Otherwise, the definition for the given type, or NULL if it is unknown.
 *
 * @see hook_search_api_data_type_info()
 */
function search_api_get_data_type_info($type = NULL) {
  return Utility::getDataTypeInfo($type);
}

/**
 * Extracts specific field values from a complex data object.
 *
 * @depreciated
 *
 * @param \Drupal\Core\TypedData\ComplexDataInterface $item
 *   The item from which fields should be extracted.
 * @param array $fields
 *   The fields to extract, passed by reference. The format is the same as the
 *   "fields" sub-array in the index options, i.e., an array with the field
 *   names as keys and arrays of field information as values, at least
 *   containing a "type" key. "value" and "original_type" keys will be added for
 *   all fields.
 */
function search_api_extract_fields(ComplexDataInterface $item, array &$fields) {
  return Utility::extractFields($item, $fields);
}

/**
 * Extracts value and original type from a single piece of data.
 *
 * @depreciated
 *
 * @param \Drupal\Core\TypedData\TypedDataInterface $data
 *   The piece of data from which to extract information.
 * @param array $field
 *   The field information array into which to put the extracted information.
 */
function _search_api_extract_field(TypedDataInterface $data, array $field) {
  return Utility::extractField($data, $field);
}

/**
 * Adds an entry into a server's list of pending tasks.
 *
 * @depreciated
 *
 * @param \Drupal\search_api\Server\ServerInterface $server
 *   The server for which a task should be remembered.
 * @param $type
 *   The type of task to perform.
 * @param \Drupal\search_api\Index\IndexInterface|string|null $index
 *   (optional) If applicable, the index to which the task pertains (or its
 *   machine name).
 * @param mixed $data
 *   (optional) If applicable, some further data necessary for the task.
 */
function search_api_server_tasks_add(ServerInterface $server, $type, $index = NULL, $data = NULL) {
  return $server->tasksAdd($type, $index, $data);
}

/**
 * Removes pending server tasks from the list.
 *
 * @depreciated
 *
 * @param array|null $ids
 *   (optional) The IDs of the pending server tasks to delete. Set to NULL
 *   to not filter by IDs.
 * @param \Drupal\search_api\Server\ServerInterface|null $server
 *   (optional) A server for which the tasks should be deleted. Set to NULL to
 *   delete tasks from all servers.
 * @param \Drupal\search_api\Index\IndexInterface|string|null $index
 *   (optional) An index (or its machine name) for which the tasks should be
 *   deleted. Set to NULL to delete tasks for all indexes.
 */
function server_api_server_tasks_delete(array $ids = NULL, ServerInterface $server = NULL, $index = NULL) {
  if ($server) {
    return $server->tasksDelete($ids, $index);
  }
  else {
    return Utility::serverTasksDelete($ids, $index);
  }
}

/**
 * Implements hook_theme().
 */
function search_api_theme() {
  $themes = array();

  $themes['search_api_admin_fields_table'] = array(
    'render element' => 'element',
  );

  $themes['search_api_server'] = array(
    'variables' => array(
      'server' => NULL,
      'indexes' => array(),
    ),
  );

  $themes['search_api_index'] = array(
    'variables' => array(
      'index' => NULL,
    ),
  );

  return $themes;
}

/**
 * Returns HTML for a field list form.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the form.
 */
function theme_search_api_admin_fields_table($variables) {
  $form = $variables['element'];
  $header = array(t('Field'), t('Machine name'), t('Indexed'), t('Type'), t('Boost'));

  $rows = array();
  if (!empty($form['fields'])) {
    foreach (\Drupal\Core\Render\Element::children($form['fields']) as $name) {
      $row = array();
      foreach (\Drupal\Core\Render\Element::children($form['fields'][$name]) as $field) {
        if ($cell = render($form['fields'][$name][$field])) {
          $row[] = $cell;
        }
      }
      if (empty($form['fields'][$name]['description']['#value'])) {
        $rows[] = _search_api_deep_copy($row);
      }
      else {
        $rows[] = array(
          'data' => $row,
          'title' => strip_tags($form['fields'][$name]['description']['#value']),
        );
      }
    }
  }

  $note = isset($form['note']) ? $form['note'] : '';
  $submit = $form['submit'];
  $additional = isset($form['additional']) ? $form['additional'] : FALSE;
  unset($form['note'], $form['submit'], $form['additional']);
  $output = drupal_render_children($form);

  $build = array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
  );

  $output .= drupal_render($build);
  $output .= render($note);
  $output .= render($submit);
  if ($additional) {
    $output .= render($additional);
  }

  return $output;
}

/**
 * Returns HTML for a Search API server.
 *
 * @param array $variables
 *   An associative array containing:
 *     - server:  A ServerInterface instance.
 *     - indexes: A renderable array which contain links to indexes associated
 *                with the server.
 *
 * @return string
 *   The rendered HTML for a Search API server.
 */
function theme_search_api_server($variables) {
  // Get the Search API server and index links.
  $server = $variables['server'];
  $indexes = $variables['indexes'];
  // Initialize the output variable to an empty string.
  $output = '';

  // Check if a description is available.
  if (($description = $server->getDescription())) {
    // Sanitiaze the description and append to the output.
    $output .= '<p class="description">' . nl2br(String::checkPlain($description)) . '</p>';
  }

  // Initialize the rows variable which will hold the different parts of server
  // information.
  $rows = array();
  // Create a row template with references so we don't have to deal with the
  // complicated structure for each inidividual row.
  $row = array(
    'data' => array(
      array('header' => TRUE),
      '',
    ),
    'class' => array(''),
  );
  // Get the individual parts of the row by reference.
  $label = &$row['data'][0]['data'];
  $info = &$row['data'][1];
  $class = &$row['class'][0];

  // Check if the server is enabled.
  if ($server->status()) {
    $class = 'ok';
    $info = t('enabled (!disable_link)', array('!disable_link' => l(t('disable'), $server->url('disable'))));
  }
  else {
    $class = 'warning';
    // Build the enable bypass url options.
    $url_options = array('query' => array('token' => \Drupal::csrfToken()->get($server->id())));
    // Build the disabled message and use the enable bypass link.
    $info = t('disabled (!enable_link)', array('!enable_link' => l(t('enabled'), $server->url('enable-bypass', $url_options))));
  }
  // Append the row and reset variables.
  $label = t('Status');
  $rows[] = _search_api_deep_copy($row);
  $class = '';

  // Check if the service used by the server is valid.
  if ($server->hasValidService()) {
    // Get the service used by the server.
    $service = $server->getService();
    // Get the service plugin definition.
    $service_plugin_definition = $service->getPluginDefinition();
    // Use the label defined in the plugin definition.
    $info = String::checkPlain($service_plugin_definition['label']);
  }
  else {
    $class = 'error';
    $info = t('Invalid or missing service plugin');
  }
  // Append the row and reset variables.
  $label = t('Service class');
  $rows[] = _search_api_deep_copy($row);
  $class = '';

  // Check if the indexes variable contains links.
  if (!empty($indexes['#links'])) {
    $label = t('Search indexes');
    $info = render($indexes);
    $rows[] = _search_api_deep_copy($row);
  }

  // Check if the server has available view settings.
  if (($options = $server->viewSettings())) {
    $label = t('Service options');
    $info = render($options);
    $rows[] = _search_api_deep_copy($row);
  }

  //
  // @todo: Add extra information once the function is available.
  //
  // Build the server info table theme variables.
  $server_info_table = array(
    '#theme' => 'table',
    '#rows' => $rows,
    '#attributes' => array(
      'class' => array(
        'search-api-summary',
        'search-api-server-summary',
        'system-status-report',
      ),
    ),
  );
  // Render the server info table and append to the output.
  $output .= drupal_render($server_info_table);

  return $output;
}

/**
 * Returns HTML for a Search API index.
 *
 * @param array $variables
 *   An associative array containing:
 *     - index: An IndexInterface instance.
 *
 * @return string
 *   The rendered HTML for a Search API index.
 */
function theme_search_api_index($variables) {
  // Get the Search API index
  $index = $variables['index'];
  $server = $index->hasValidServer() ? $index->getServer() : NULL;
  $datasource = $index->hasValidDatasource() ? $index->getDatasource() : NULL;
  // Initialize the output variable to an empty string.
  $output = '';

  // Check if a description is available.
  if (($description = $index->getDescription())) {
    // Sanitiaze the description and append to the output.
    $output .= '<p class="description">' . nl2br(String::checkPlain($description)) . '</p>';
  }

  // Initialize the rows variable which will hold the different parts of server
  // information.
  $rows = array();
  // Create a row template with references so we don't have to deal with the
  // complicated structure for each inidividual row.
  $row = array(
    'data' => array(
      array('header' => TRUE),
      '',
    ),
    'class' => array(''),
  );
  // Get the individual parts of the row by reference.
  $label = &$row['data'][0]['data'];
  $info = &$row['data'][1];
  $class = &$row['class'][0];

  // Check if the index is enabled.
  if ($index->status()) {
    $class = 'ok';
    $info = t ('enabled (!disable_link)', array ('!disable_link' => l (t ('disable'), $index->url ('disable'))));
  }
  // Check if a server is available and enabled.
  elseif ($server && $server->status()) {
    $class = 'warning';
    // Build the enable bypass url options.
    $url_options = array('query' => array('token' => \Drupal::csrfToken()->get($index->id())));
    // Build the disabled message and use the enable bypass link.
    $info = t('disabled (!enabled_link)', array('!enabled_link' => l(t('enable'), $index->url('enable-bypass', $url_options))));
  }
  else {
    $class = 'warning';
    $info = t('disabled');
  }
  // Append the row and reset variables.
  $label = t('Status');
  $rows[] = _search_api_deep_copy($row);
  $class = '';

  // Check if a datasource is available.
  if ($datasource) {
    // Get the datasource plugin definition.
    $datasource_plugin_definition = $datasource->getPluginDefinition();
    // Use the label defined in the plugin definition.
    $info = $datasource_plugin_definition['label'];
  }
  else {
    $class = 'error';
    $info = t('Invalid or missing datasource plugin');
  }
  // Append the row and reset variables.
  $label = t('Item type');
  $rows[] = _search_api_deep_copy($row);
  $class = '';

  // Check if a server is available.
  if ($server) {
    $label = t('Server');
    $info = l($server->label(), $server->url('canonical'));
    $rows[] = _search_api_deep_copy($row);
  }

  // Check if the index is enabled and a datasource is available.
  if ($index->status() && $datasource) {
    // Get the configured options, merge in default options to prevent notice
    // when an index is missing the required options.
    $options = $index->getOptions() + array('cron_limit' => SEARCH_API_DEFAULT_CRON_LIMIT);
    // Check if the cron limit is higher then zero.
    if ($options['cron_limit'] > 0) {
      $class = 'ok';
      $info = \Drupal::translation()->formatPlural($options['cron_limit'], 'During cron runs, 1 item will be indexed per batch.', 'During cron runs, @count items will be indexed per batch.');
    }
    else {
      $class = 'warning';
      $info = t('No items will be indexed during cron runs.');
    }
    // Append the row and reset variables.
    $label = t('Cron batch size');
    $rows[] = _search_api_deep_copy($row);
    $class = '';
    //
    // @todo: Get server status info.
    //
    // @todo: Get index status info.
    //
    // Build the index progress bar.
    $index_progress = array(
      '#theme' => 'progress_bar',
      '#percent' => 0,
      '#message' => t('@indexed/@total indexed', array('@indexed' => 0, '@total' => 0)),
    );
    // Add the progress bar to the output.
    $output .= '<h3>' . t('Index status') . '</h3>';
    $output .= '<div class="search-api-index-status">' . drupal_render($index_progress) . '</div>';
  }

  // Build the index info table theme variables.
  $index_info_table = array(
    '#theme' => 'table',
    '#rows' => $rows,
    '#attributes' => array(
      'class' => array(
        'search-api-summary',
        'search-api-index-summary',
        'system-status-report',
      ),
    ),
  );
  // Render the server info table and append to the output.
  $output .= drupal_render($index_info_table);

  return $output;
}

/**
 * Returns a deep copy of the input array.
 *
 * The behavior of PHP regarding arrays with references pointing to it is rather
 * weird. Therefore, we use this helper function in theme_search_api_index() to
 * create safe copies of such arrays.
 *
 * @param array $array
 *   The array to copy.
 *
 * @return array
 *   A deep copy of the array.
 */
function _search_api_deep_copy(array $array) {
  $copy = array();
  foreach ($array as $k => $v) {
    if (is_array($v)) {
      $copy[$k] = _search_api_deep_copy($v);
    }
    elseif (is_object($v)) {
      $copy[$k] = clone $v;
    }
    elseif ($v) {
      $copy[$k] = $v;
    }
  }
  return $copy;
}

/**
 * Implements hook_entity_type_build().
 */
function search_api_entity_type_build(array &$entity_types) {
  /** @var $entity_types \Drupal\Core\Entity\EntityTypeInterface[] */
  if (isset($entity_types['node'])) {
    $entity_types['node']->set('search_api_default_fields', array(
      'node:title' => array(
        'type' => 'string',
      ),
      'node:path' => array(
        'type' => 'string',
      ),
      'node:created' => array(
        'type' => 'date',
      ),
      'node:changed' => array(
        'type' => 'date',
      )
    ));
  }
}
