<?php
// $Id$

/**
 * Default number of items indexed at each cron run for each enabled index.
 */
define('SEARCH_API_DEFAULT_CRON_LIMIT', 50);

/**
 * Implements hook_menu().
 */
function search_api_menu() {
  $pre = 'admin/config/search/search_api';
  $items[$pre] = array(
    'title' => 'Search API',
    'description' => 'Create and configure searches.',
    'page callback' => 'search_api_admin_overview',
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
  );
  $items[$pre . '/overview'] = array(
    'title' => 'Overview',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items[$pre . '/add_server'] = array(
    'title' => 'Add server',
    'description' => 'Create a new search server.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_add_server'),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/add_index'] = array(
    'title' => 'Add index',
    'description' => 'Create a new search index.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_add_index'),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/server/%search_api_server'] = array(
    'title' => 'View server',
    'description' => 'View server details.',
    'page callback' => 'search_api_admin_server_view',
    'page arguments' => array(5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items[$pre . '/server/%search_api_server/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items[$pre . '/server/%search_api_server/edit'] = array(
    'title' => 'Edit',
    'description' => 'Edit server details.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_server_edit', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/server/%search_api_server/delete'] = array(
    'title' => 'Delete',
    'description' => 'Delete server.',
    'page callback' => 'drupal_get_form',
    'page arguments' =>
        array('search_api_admin_confirm', 'server', 'delete', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/index/%search_api_index'] = array(
    'title' => 'View index',
    'description' => 'View index details.',
    'page callback' => 'search_api_admin_index_view',
    'page arguments' => array(5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items[$pre . '/index/%search_api_index/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items[$pre . '/index/%search_api_index/edit'] = array(
    'title' => 'Edit',
    'description' => 'Edit index details.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_admin_index_edit', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
  );
  $items[$pre . '/index/%search_api_index/delete'] = array(
    'title' => 'Delete',
    'description' => 'Delete index.',
    'page callback' => 'drupal_get_form',
    'page arguments' =>
        array('search_api_admin_confirm', 'index', 'delete', 5),
    'access arguments' => array('administer search_api'),
    'file' => 'search_api.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function search_api_permission() {
  return array(
    'administer search_api' => array(
      'title' => t('Administer Search API'),
      'description' =>
          t('Create and configure Search API servers and indexes.'),
    ),
    // @todo Do we need this?
    /*'access search_api' => array(
      'title' => t('Access Search API searches'),
      'description' => t('Gives users access to searches created with the ' .
          'Search API.'),
    ),*/
  );
}

/**
 * Implements hook_cron().
 *
 * Will index $options['cron-limit'] items for each enabled index.
 */
function search_api_cron() {
  foreach (search_api_list_indexes() as $index) {
    $limit = isset($index->options['cron_limit'])
        ? $index->options['cron_limit']
        : SEARCH_API_DEFAULT_CRON_LIMIT;
    if ($limit) {
      $num = search_api_index_items($index, $limit);
      if ($num) {
        watchdog('search_api', t('Indexed !num items for index !name',
            array('!num' => $num, '!name' => $index->name)), NULL,
            WATCHDOG_INFO);
      }
    }
  }
}

// @todo Implement hook_entity_info() for indexes and servers?

/**
 * Implements hook_entity_insert().
 *
 * Marks the new item as to-index for all indexes on entities of the specified
 * type.
 *
 * @param $entity
 *   The new entity.
 * @param $type
 *   The entity's type.
 */
function search_api_entity_insert($entity, $type) {
  $info = entity_get_info($type);
  $id = $info['entity keys']['id'];
  foreach (search_api_list_indexes(array('entity_type' => $type)) as $index) {
    db_insert('search_api_item')
      ->fields(array(
        'item_id' => $entity->$id,
        'index_id' => $index->id,
        'changed' => 1,// Set always to 1 to index new items before changed ones
      ))
      ->execute();
  }
}

/**
 * Implements hook_entity_update().
 *
 * Marks the item as changed for all indexes on entities of the specified type.
 *
 * @param $entity
 *   The updated entity.
 * @param $type
 *   The entity's type.
 */
function search_api_entity_update($entity, $type) {
  $info = entity_get_info($type);
  $id = $info['entity keys']['id'];
  foreach (search_api_list_indexes(array('entity_type' => $type)) as $index) {
    db_update('search_api_item')
      ->fields(array(
        'changed' => REQUEST_TIME,
      ))
      ->condition('item_id', $entity->$id)
      ->condition('index_id', $index->id)
      ->condition('changed', 0)
      ->execute();
  }
}

/**
 * Implements hook_search_api_alter_callback_info().
 */
function search_api_search_api_alter_callback_info() {
  $callbacks['search_api_alter_prepare_view'] = array(
    'name' => t('Call hook'),
    'description' =>
        t('Calls the standard entity_prepare_view() function for all items.'),
    'weight' => -10,
  );
  // @todo Add heavy-weight callback that aggregates string fields into a
  // search_api_fulltext field at index time

  return $callbacks;
}

/**
 * Indexes items for the specified index. Only items marked as changed are
 * indexed, in their order of change (if known).
 *
 * @param $index
 *   The index on which items should be indexed.
 * @param $limit
 *   The number of items which should be indexed at most. -1 means no limit.
 *
 * @return
 *   Number of successfully indexed items, or FALSE if an error occurred.
 */
function search_api_index_items($index, $limit) {
  $entity_info = entity_get_info($index->entity_type);
  // Safety check if entity type is known (prevent failing of whole cron run)
  if (!$entity_info) {
    watchdog('search_api', t("Couldn't index values for '!name' index " .
        "(unknown entity type '!type')", array('!name' => $index->name,
        '!type' => $index->entity_type)), NULL, WATCHDOG_ERROR);
    return FALSE;
  }

  $server = search_api_server_load($index->server);
  if (!($server && $server instanceof SearchApiServiceInterface)) {
    watchdog('search_api', t("Couldn't index values for '!name' index " .
        '(server info could not be retrieved)', array('!name' => $index->name)),
        NULL, WATCHDOG_ERROR);
    return FALSE;
  }

  $items = search_api_get_items_to_index($index, $limit);
  if (!$items) {
    return 0;
  }
  search_api_item_data_alter('index', $index, $items);
  if (!$items) {
    return 0;
  }
  search_api_item_preprocess('index', $index, $items);
  $indexed = $server->index($index, $items);

  if (!empty($indexed)) {
    search_api_set_items_indexed($index, $indexed);
  }

  return count($indexed);
}

/**
 * Returns a list of at most $limit items that need to be indexed for the
 * specified index.
 *
 * @param $index
 *   The index for which items should be retrieved.
 * @param $limit
 *   The maximum number of items to retrieve. -1 means no limit.
 *
 * @return
 *   An array of items (entities) that need to be indexed.
 */
function search_api_get_items_to_index($index, $limit = -1) {
  if ($limit == 0) {
    return array();
  }
  $select = db_select('search_api_item', 'i');
  $select->addField('i', 'item_id');
  $select->condition('index_id', $index->id);
  $select->condition('changed', 0, '<>');
  $select->orderBy('changed', 'ASC');
  if ($limit > 0) {
    $select->range(0, $limit);
  }

  $ids = $select->execute()->fetchCol();
  return entity_load($index->entity_type, $ids);
}

/**
 * Calls data alteration hooks for a set of items, according to the index
 * options.
 *
 * @param $index
 *   The index on which the items will be indexed.
 * @param $items
 *   An array of items to be altered.
 */
function search_api_item_data_alter($index, &$items) {
  if (empty($index->options['data_alter_callbacks'])) {
    return;
  }

  foreach ($index->options['data_alter_callbacks'] as $func) {
    if (!function_exists($func)) {
      watchdog('search_api', t('Undefined data alter callback function ' .
          '!function() specified in index !name', array('!function' => $func,
          '!name' => $index->name)), NULL, WATCHDOG_WARNING);
      continue;
    }
    $func($index, $items);
    if (empty($items)) {
      return;
    }
  }
}

/**
 * Runs all preprocessors that are active for the specified index on the given
 * items.
 *
 * @param $phase
 *   The phase in which this call occurs. Either 'index' or 'search'.
 * @param $index
 *   The index on which the items are indexed.
 * @param $data
 *   An array of items to be preprocessed at index time, or a SearchApiQuery
 *   object at search time.
 */
function search_api_item_preprocess($phase, $index, &$data) {
  if (empty($index->options['preprocessors'])) {
    return;
  }

  $processors = &drupal_static(__FUNCTION__);

  foreach ($index->options['preprocessors'] as $class) {
    if (!class_exists($class)) {
      watchdog('search_api', t('Undefined preprocessor class !class ' .
          'specified in index !name', array('!class' => $class,
          '!name' => $index->name)), NULL, WATCHDOG_WARNING);
      continue;
    }
    if (empty($processors[$class])) {
      $processors[$class] = new $class;
    }
    if (!($processors[$class] instanceof SearchApiProcessorInterface)) {
      watchdog('search_api', t('Undefined preprocessor class !class ' .
          'specified in index !name', array('!class' => $class,
          '!name' => $index->name)), NULL, WATCHDOG_WARNING);
      continue;
    }

    switch ($phase) {
      case 'index':
        $processors[$class]->preprocessIndexItems($index, $data);
        break;
      case 'search':
        $processors[$class]->preprocessSearchQuery($index, $data);
        break;
      default:
        watchdog('search_api', t('!function() called with unknown phase !phase',
            array('!function' => __FUNCTION__, '!phase' => $phase)), NULL,
            WATCHDOG_WARNING);
        return;
    }
  }
}

/**
 * Runs all postprocessors that are active for the specified index on the given
 * search results.
 *
 * @param $index
 *   The index on which the items are indexed.
 * @param $query
 *   The SearchApiQuery object representing the executed query.
 * @param $results
 *   An array of search results.
 */
function search_api_item_postprocess($index, $query, &$results) {
  if (empty($index->options['postprocessors'])) {
    return;
  }

  // Use the same processors as in preprocessing,if possible
  $processors = &drupal_static('search_api_item_preprocess');

  foreach ($index->options['postprocessors'] as $class) {
    if (!class_exists($class)) {
      watchdog('search_api', t('Undefined postprocessor class !class ' .
          'specified in index !name', array('!class' => $class,
          '!name' => $index->name)), NULL, WATCHDOG_WARNING);
      continue;
    }
    if (empty($processors[$class])) {
      $processors[$class] = new $class;
    }
    if (!($processors[$class] instanceof SearchApiProcessorInterface)) {
      watchdog('search_api', t('Undefined postprocessor class !class ' .
          'specified in index !name', array('!class' => $class,
          '!name' => $index->name)), NULL, WATCHDOG_WARNING);
      continue;
    }
    $processors[$class]->postprocessSearchResults($index, $query, $results);
  }
}

/**
 * Marks the items as successfully indexed for the specified index.
 *
 * @param $index
 *   The index on which items were indexed.
 * @param $ids
 *   The ids of the indexed items.
 *
 * @return
 *   The number of index entries changed.
 */
function search_api_set_items_indexed($index, $ids) {
  return db_update('search_api_item')
      ->fields(array(
        'changed' => 0,
      ))
      ->condition('index_id', $index->id)
      ->condition('item_id', $ids, 'IN')
      ->execute();
}

/**
 * Search API data alteration callback that calls entity_prepare_view() for all
 * items.
 *
 * @param $phase
 *   The phase in which this call occurs. Either 'index' or
 *   'search'.
 * @param $index
 *   The index on which the items are indexed.
 * @param $items
 *   An array of objects containing the entity data.
 */
function search_api_alter_prepare_view($phase, $index, &$items) {
  entity_prepare_view($index->entity_type, $items);
}

/**
 * Execute a search on a search index.
 *
 * @param $index
 *   The index to execute the search on.
 * @param $keys
 *   Fulltext keys to search for. May be NULL to do a filter search.
 * @param $options
 *   An associative array of options. The following are recognized:
 *   - filters: Either a SearchApiQueryFilter object or an array of filters used
 *     to filter the search.
 *   - sort: An array of sort directives of the form $field => $order, where
 *     $order is either 'ASC' or 'DESC'.
 *   - offset: The position of the first returned search results relative to the
 *     whole result in the index.
 *   - limit: The maximum number of search results to return. -1 means no limit.
 *   - 'query class': The query class to use. Must be a subtype of
 *     SearchApiQuery.
 *   - conjunction: The type of conjunction to use for this query - either
 *     'AND' or 'OR'. 'AND' by default.
 *   - 'parse mode': The mode with which to parse the $keys variable, if it
 *     is set and not already an array. See SearchApiQuery::parseModes() for
 *     parse modes recognized by the SearchApiQuery class. Subclasses might
 *     define additional modes.
 * @return
 *   An associative array containing the search results. For its exact contents,
 *   see SearchApiServiceInterface->search().
 */
function search_api_search($index, $keys = NULL, array $options = array()) {
  $server = search_api_server_load($index->server);
  if (!($server && $server instanceof SearchApiServiceInterface)) {
    watchdog('search_api', t("Couldn't search values for '!name' index " .
        '(server info could not be retrieved)', array('!name' => $index->name)),
        NULL, WATCHDOG_ERROR);
    return FALSE;
  }

  // Set option defaults
  $options += array('filters' => array(), 'sort' => array(), 'offset' => 0,
      'limit' => -1, 'query class' => 'SearchApiQuery', 'conjunction' => 'AND',
      'parse mode' => 'terms');

  // Create query object
  $query_options = array('conjunction' => $options['conjunction'],
      'parse mode' => $options['parse mode']);
  $query = NULL;
  if (class_exists($options['query class'])) {
    $query = new $options['query class']($keys, $query_options);
  }

  if (!($query instanceof SearchApiQuery)) {
    watchdog('search api', t('Illegal query class !class specified for search.',
        array('!class' => $options['query class'])), NULL, WATCHDOG_ERROR);
    return FALSE;
  }

  // Add filters and sorts
  $filters = $options['filters'];
  $sorts   = $options['sorts'];
  if ($filters) {
    if (is_array($filters)) {
      $ref1 = &$query->filter();
      $ref2 = &$ref1->filters();
      $ref2 = $filters;
    }
    else if ($filters instanceof SearchApiQueryFilter) {
      $query->addFilter($filters);
    }
    else {
      watchdog('search api', t('Illegal filter value specified for search: ' .
          '!value', array('!value' => print_r($filters, TRUE))), NULL,
          WATCHDOG_WARNING);
    }
  }
  if ($sort && is_array($sort)) {
    foreach ($sort as $field => $order) {
      $query->addSort($field, $order);
    }
  }

  // Preprocess query
  search_api_item_preprocess('search', $index, $query);

  // Let modules alter the query
  drupal_alter($query, $index);

  // Cache query (e.g. for facets)
  $query_cache = &drupal_static(__FUNCTION__ . '_query');
  $query_cache[] = $query;

  // Execute query
  $search_options = array('offset' => $options['offset'],
      'limit' => $options['limit']);
  $result = $server->search($index, $query, $search_options);

  // Postprocess results
  search_api_item_postprocess($index, $results);

  // Cache results
  $result_cache = &drupal_static(__FUNCTION__ . '_results');
  $result_cache[] = $results;

  return $results;
}

/**
 * Returns either a list of all available service infos, or a specific one.
 *
 * @see hook_search_api_service_info()
 *
 * @param $id
 *   The id of the service info to retrieve.
 *
 * @return
 *   If $id was not specified, an array of all available service classes.
 *   Otherwise, either the service info with the specified id (if it exists),
 *   or NULL.
 */
function search_api_get_service_info($id = NULL) {
  $services = &drupal_static(__FUNCTION__);

  if (!isset($services)) {
    $services = module_invoke_all('search_api_service_info');

    // Initialization of optional entries with default values
    foreach ($services as $id => $service) {
      if (!isset($service['init args'])) {
        $services[$id]['init args'] = array();
      }
    }

    // Allow other modules to alter definitions
    drupal_alter('search_api_service_info', $services);
  }

  if (isset($id)) {
    return isset($services[$id]) ? $services[$id] : NULL;
  }
  return $services;
}

/**
 * Returns a list of all available data alter callbacks.
 *
 * @see hook_search_api_alter_callback_info()
 *
 * @return
 *   An array of all available data alter callbacks, keyed by function name.
 */
function search_api_get_alter_callbacks() {
  $callbacks = &drupal_static(__FUNCTION__);

  if (!isset($callbacks)) {
    $callbacks = module_invoke_all('search_api_alter_callback_info');

    // Initialization of optional entries with default values
    foreach ($callbacks as $id => $callback) {
      $callbacks[$id] += array('enabled' => TRUE, 'weight' => 0);
    }

    // @todo drupal_alter('search_api_alter_callback_info', $callbacks)?
  }

  return $callbacks;
}

/**
 * Returns a list of all available pre- and post-processors.
 *
 * @see hook_search_api_processor_info()
 *
 * @return
 *   An array of all available processors, keyed by id.
 */
function search_api_get_processors() {
  $processors = &drupal_static(__FUNCTION__);

  if (!isset($processors)) {
    $processors = module_invoke_all('search_api_processor_info');

    // Initialization of optional entries with default values
    foreach ($processors as $id => $processor) {
      $processors[$id] += array('enabled pre' => TRUE, 'enabled post' => TRUE,
          'weight' => 0);
    }

    // @todo drupal_alter('search_api_processor_info', $processors)?
  }

  return $processors;
}

/**
 * Returns a list of all (enabled) search servers.
 *
 * @param $only_enabled
 *   Whether to retrieve only enabled servers.
 * @param $header
 *   A table header to sort by.
 *
 * @return
 *   An array of objects representing all (or, if $enabled is TRUE, only
 *   enabled) search servers.
 */
function search_api_list_servers($only_enabled = TRUE, $header = NULL) {
  $servers = &drupal_static(__FUNCTION__);

  $enabled = (int) $only_enabled;
  if (!isset($servers[$enabled])) {
    $select = db_select('search_api_server', 's')->fields('s');
    if ($enabled) {
      $select->condition('s.enabled', 1);
    }
    if (!empty($header)) {
      $select = $select->extend('TableSort')->orderByHeader($header);
    }

    $results = $select->execute();
    $servers[$enabled] = array();
    foreach ($results as $row) {
      $row->options = unserialize($row->options);
      $servers[$enabled][$row->id] = $row;
    }
  }

  return $servers[$enabled];
}

/**
 * Load the search server with the specified id.
 *
 * @param $id
 *   The search server's id.
 *
 * @return
 *   The loaded and initialized SearchApiServiceInterface object
 *   representing the server with the specified id.
 */
function search_api_server_load($id) {
  $servers = &drupal_static(__FUNCTION__);

  if (!isset($servers[$id])) {
    $server = db_query('SELECT * FROM {search_api_server} WHERE id = :id',
        array(':id' => (int) $id))->fetch();

    if (!$server) {
      watchdog('search_api', t('Unknown search server with id !id',
          array('!id' => $id)), NULL, WATCHDOG_WARNING);
      $servers[$id] = FALSE;
      return NULL;
    }

    // Load corresponding service class
    $obj = NULL;
    $service = search_api_get_service_info($server->class);
    if ($service && class_exists($service['class'])) {
      $obj = new $service['class'];
    }

    if (!($obj instanceof SearchApiServiceInterface)) {
      // @todo Add link to server configuration once admin pages are implemented
      watchdog('search_api',
          t('Server with id !id specifies illegal service class !class',
          array('!id' => $id, '!class' => $server->class)), NULL, WATCHDOG_ERROR);
      $servers[$id] = FALSE;
      return NULL;
    }

    // Copy db values to service object
    foreach ($server as $field => $value) {
      $obj->$field = $value;
    }

    // Initialize service object
    $obj->options = unserialize($obj->options);
    $obj->init($obj->options, $service['init args']);

    $servers[$id] = $obj;
  }

  return $servers[$id] ? $servers[$id] : NULL;
}

/**
 * Returns a list of search indexes.
 *
 * @param $options
 *   An associative array of conditions on the returned indexes.
 *   - only_enabled: Unless set to FALSE, only enabled indexes will be returned.
 *   - server: Return only indexes on the server with the specified id.
 *   - entity_type: Return only indexes on the specified entity type.
 * @param $header
 *   A table header to sort by.
 *
 * @return
 *   An array of objects representing the search indexes that meet the
 *   specified criteria.
 */
function search_api_list_indexes(array $options = array(), $header = NULL) {
  $enabled = isset($options['only_enabled']) && !$options['only_enabled']
      ? 0 : 1;
  $server = empty($options['server']) ? NULL : $options['server'];
  $type = empty($options['entity_type']) ? NULL : $options['entity_type'];

  $select = db_select('search_api_index', 'i')->fields('i');
  if ($enabled) {
    $select->condition('i.enabled', 1);
  }
  if (!empty($server)) {
    $select->condition('i.server', $server);
  }
  if (!empty($type)) {
    $select->condition('i.entity_type', $type);
  }
  if (!empty($header)) {
    $select = $select->extend('TableSort')->orderByHeader($header);
  }

  $results = $select->execute();
  $indexes = array();
  foreach ($results as $row) {
    $row->options = unserialize($row->options);
    $indexes[$row->id] = $row;
  }

  return $indexes;
}

/**
 * Loads the Search API index with the specified id.
 *
 * @param $id
 *   The index' id.
 *
 * @return
 *   A completely loaded index object, or NULL if no such index exists.
 */
function search_api_index_load($id) {
  $result = db_query('SELECT * FROM {search_api_index} WHERE id = :id',
      array(':id' => (int) $id))->fetchObject();
  if (!$result) {
    watchdog('search_api', t('Unknown search index with id !id',
        array('!id' => $id)), NULL, WATCHDOG_WARNING);
    return NULL;
  }
  $result->options = unserialize($result->options);

  return $result;
}
